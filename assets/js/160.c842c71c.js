(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{834:function(v,_,t){"use strict";t.r(_);var s=t(4),e=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/bigben0123/p/9115597.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("推荐Blog"),t("OutboundLink")],1)]),v._v(" "),t("h2",{attrs:{id:"单线程的redis为什么这么快"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程的redis为什么这么快"}},[v._v("#")]),v._v(" 单线程的redis为什么这么快")]),v._v(" "),t("p",[v._v("主要是以下三点")]),v._v(" "),t("ul",[t("li",[v._v("纯内存操作")]),v._v(" "),t("li",[v._v("单线程操作，避免了频繁的上下文切换")]),v._v(" "),t("li",[v._v("采用了非阻塞I/O多路复用机制")])]),v._v(" "),t("h2",{attrs:{id:"i-o多路复用机制是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#i-o多路复用机制是什么"}},[v._v("#")]),v._v(" I/O多路复用机制是什么")]),v._v(" "),t("p",[t("img",{attrs:{src:"i/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg",alt:"多路复用"}})]),v._v(" "),t("ul",[t("li",[v._v("一个多路复用程序监听端口")]),v._v(" "),t("li",[v._v("多个请求连接到达时，通过跟踪多个socket的状态控制多个IO操作")])]),v._v(" "),t("p",[v._v("不用多线程并发模型接受连接的原因：")]),v._v(" "),t("ul",[t("li",[v._v("线程间的协调耗时长")])]),v._v(" "),t("h2",{attrs:{id:"redis-value的数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-value的数据类型"}},[v._v("#")]),v._v(" Redis value的数据类型")]),v._v(" "),t("p",[v._v("Redis是key-value数据库，key是string，value类型有多种")]),v._v(" "),t("h3",{attrs:{id:"string"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[v._v("#")]),v._v(" String")]),v._v(" "),t("ul",[t("li",[v._v("Redis 最基本的数据类型，一个 key 对应一个 value")]),v._v(" "),t("li",[v._v("SET, GET 等命令")])]),v._v(" "),t("h3",{attrs:{id:"hash"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[v._v("#")]),v._v(" Hash")]),v._v(" "),t("ul",[t("li",[v._v("Redis hash 是一个键值(key=>value)对集合。")]),v._v(" "),t("li",[v._v("Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。")]),v._v(" "),t("li",[v._v("HMSET, HGET 等命令")]),v._v(" "),t("li",[v._v("存储、读取、修改用户属性")])]),v._v(" "),t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[v._v("#")]),v._v(" List")]),v._v(" "),t("ul",[t("li",[v._v("Redis List是简单的字符串列表，按照插入顺序排序。")]),v._v(" "),t("li",[v._v("你可以添加一个元素到列表的头部（左边）或者尾部（右边）。")]),v._v(" "),t("li",[v._v("LPUSH, RPUSH 等命令")]),v._v(" "),t("li",[v._v("最新消息排行等功能(比如朋友圈的时间线)；消息队列")])]),v._v(" "),t("h3",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[v._v("#")]),v._v(" Set")]),v._v(" "),t("ul",[t("li",[v._v("Redis的Set是string类型的无序集合，不允许重复的成员。")]),v._v(" "),t("li",[v._v("重复的插入将被忽略。")]),v._v(" "),t("li",[v._v("集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。")]),v._v(" "),t("li",[v._v("SADD, SMEMBERS 等命令，有交并补等功能")]),v._v(" "),t("li",[v._v("共同好友；利用唯一性，统计访问网站的所有独立ip；好友推荐时求交集")])]),v._v(" "),t("h3",{attrs:{id:"zset-sorted-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zset-sorted-set"}},[v._v("#")]),v._v(" zset(sorted set)")]),v._v(" "),t("ul",[t("li",[v._v("Redis zset 和 set 一样也是string类型元素的集合，不允许重复的成员。")]),v._v(" "),t("li",[v._v("每个元素在插入时都必须关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。")]),v._v(" "),t("li",[v._v("ZSADD 等命令")]),v._v(" "),t("li",[v._v("排行榜；带权重的消息队列")])]),v._v(" "),t("h2",{attrs:{id:"redis清内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis清内存"}},[v._v("#")]),v._v(" Redis清内存")]),v._v(" "),t("h3",{attrs:{id:"定期删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定期删除"}},[v._v("#")]),v._v(" 定期删除")]),v._v(" "),t("p",[v._v("每100ms"),t("strong",[v._v("随机")]),v._v("地检查一些key看是否过期，过期则删除")]),v._v(" "),t("p",[v._v("（如果每次检查都查全部的key会卡卡卡）")]),v._v(" "),t("h3",{attrs:{id:"惰性删除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除"}},[v._v("#")]),v._v(" 惰性删除")]),v._v(" "),t("p",[v._v("请求获取key的时候检查是否过期")]),v._v(" "),t("h3",{attrs:{id:"内存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存淘汰策略"}},[v._v("#")]),v._v(" 内存淘汰策略")]),v._v(" "),t("p",[v._v("在redis.conf中有一行配置")]),v._v(" "),t("div",{staticClass:"language-conf line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("maxmemory-policy volatile-lru\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("ul",[t("li",[v._v("noeviction：当内存不足以容纳新写入数据时，新写入操作会"),t("strong",[v._v("报错")]),v._v("。"),t("strong",[v._v("用的不多")])]),v._v(" "),t("li",[v._v("allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，"),t("strong",[v._v("移除最近最少使用")]),v._v("的key。"),t("strong",[v._v("用的比较多")])]),v._v(" "),t("li",[v._v("allkeys-random：当内存不足以容纳新写入数据时，在键空间中，"),t("strong",[v._v("随机移除")]),v._v("某个key。"),t("strong",[v._v("用的不多")])]),v._v(" "),t("li",[v._v("volatile-lru：当内存不足以容纳新写入数据时，"),t("strong",[v._v("在设置了过期时间的键空间")]),v._v("中，"),t("strong",[v._v("移除最近最少使用")]),v._v("的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。")]),v._v(" "),t("li",[v._v("volatile-random：当内存不足以容纳新写入数据时，"),t("strong",[v._v("在设置了过期时间的键空间")]),v._v("中，随机移除某个key。")]),v._v(" "),t("li",[v._v("volatile-ttl：当内存不足以容纳新写入数据时，"),t("strong",[v._v("在设置了过期时间的键空间")]),v._v("中，"),t("strong",[v._v("有更早过期时间")]),v._v("的key优先移除。")])]),v._v(" "),t("h2",{attrs:{id:"redis和数据库双写一致性问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis和数据库双写一致性问题"}},[v._v("#")]),v._v(" redis和数据库双写一致性问题")]),v._v(" "),t("ul",[t("li",[v._v("双写一致性只能保证"),t("strong",[v._v("最终一致性")]),v._v("，不能保证"),t("strong",[v._v("强一致性")])]),v._v(" "),t("li",[v._v("如果对数据有强一致性要求，不能放缓存")]),v._v(" "),t("li",[v._v("采取正确更新策略，先更新数据库，再更新缓存")])]),v._v(" "),t("h2",{attrs:{id:"缓存穿透问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透问题"}},[v._v("#")]),v._v(" 缓存穿透问题")]),v._v(" "),t("p",[v._v("黑客故意请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。")]),v._v(" "),t("p",[v._v("解决方法：")]),v._v(" "),t("ol",[t("li",[v._v("互斥锁：缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没有则休眠一段时间重试，保证一次只有一个请求到达数据库")]),v._v(" "),t("li",[v._v("异步更新策略：无论key是否取到值，都直接返回，不去访问数据库。更新缓存的程序放在别的进程里面。需要"),t("strong",[v._v("缓存预热")]),v._v("(项目启动前，先加载缓存)")]),v._v(" "),t("li",[v._v("提供一个能迅速判断请求是否有效的拦截机制")])]),v._v(" "),t("h2",{attrs:{id:"缓存雪崩问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩问题"}},[v._v("#")]),v._v(" 缓存雪崩问题")]),v._v(" "),t("p",[v._v("因为过期时间相同，大量的缓存在同一时间过期，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。")]),v._v(" "),t("p",[v._v("解决方法：")]),v._v(" "),t("ol",[t("li",[v._v("还是上面的互斥锁：这种方法有用但是会导致性能大幅下降")]),v._v(" "),t("li",[v._v("给缓存时间加随机值，避免大量同时失效")]),v._v(" "),t("li",[v._v("双缓存：两个缓存，缓存A有失效时间，缓存B没有失效时间。\n"),t("ul",[t("li",[v._v("从缓存A读数据，有则直接返回，没有就下一步")]),v._v(" "),t("li",[v._v("从缓存B读数据，并且启动更新操作同时更新AB")])])])]),v._v(" "),t("h2",{attrs:{id:"并发set问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发set问题"}},[v._v("#")]),v._v(" 并发SET问题")]),v._v(" "),t("p",[v._v("同时有多个子系统去set一个key")]),v._v(" "),t("p",[v._v("解决方法：参考操作系统里面学的进程同步")]),v._v(" "),t("ul",[t("li",[v._v("没有顺序的操作：设一个锁，抢到锁的才能SET")]),v._v(" "),t("li",[v._v("有顺序的操作：设几个锁，按步骤来的操作依次抢锁.比如要使一个值按照1👉2👉3的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下：\n"),t("ul",[t("li",[v._v("系统A key 1 {valueA  3:00}")]),v._v(" "),t("li",[v._v("系统B key 1 {valueB  3:05}")]),v._v(" "),t("li",[v._v("系统C key 1 {valueC  3:10}")])])])]),v._v(" "),t("p",[v._v("那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。")])])}),[],!1,null,null,null);_.default=e.exports}}]);