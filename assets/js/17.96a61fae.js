(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{614:function(_,v,t){_.exports=t.p+"assets/img/Full_Cone_NAT.f5c3cf2c.svg"},615:function(_,v,t){_.exports=t.p+"assets/img/Restricted_Cone_NAT.6477c4ac.svg"},616:function(_,v,t){_.exports=t.p+"assets/img/Port_Restricted_Cone_NAT.0855497b.svg"},617:function(_,v,t){_.exports=t.p+"assets/img/Symmetric_NAT.a124ca2a.svg"},618:function(_,v,t){_.exports=t.p+"assets/img/UPnP.e18c6186.png"},619:function(_,v,t){_.exports=t.p+"assets/img/UPnPFlow.98f1e240.png"},719:function(_,v,t){"use strict";t.r(v);var e=t(4),o=function(_){_.options.__data__block__={mermaid_382ee1a3:"graph LR\ni.Addr(内部主机<br>i.Addr:iPort)\ne.Addr[i.Addr:iPort->NAT->e.Addr:ePort]\ns.Addr(外部主机<br>s.Addr:sPort)\ni.Addr--\x3ee.Addr--\x3es.Addr\n",mermaid_64a56864:"graph LR\ni.Addr(`Host_1`<br>i.Addr:iPort)\nNATi[NAT1<br>e.1.Addr:e1Port]\nj.Addr(`Host_2`<br>i.Addr:iPort)\nNATj[NAT2<br>e.2.Addr:e2Port]\ns.Addr(STUN服务器<br>s.Addr:3478)\ni.Addr--\x3eNATi--\x3es.Addr\nj.Addr--\x3eNATj--\x3es.Addr\n"}},r=Object(e.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("网络地址转换(Network Address Translation, NAT)是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在"),e("strong",[_._v("有多台主机但只通过一个公有IP地址访问互联网")]),_._v("的私有网络中。")]),_._v(" "),e("p",[_._v("NAT的优点：")]),_._v(" "),e("ul",[e("li",[_._v("节省IP地址，为IPv4续命")]),_._v(" "),e("li",[_._v("来自外部网络的连接不能轻易到达内网，一定程度上保障了内部网络安全")])]),_._v(" "),e("p",[_._v("NAT的主要缺点：")]),_._v(" "),e("ul",[e("li",[_._v("一些需要初始化从外部网络创建的TCP连接和无状态协议（比如UDP）无法实现\n"),e("ul",[e("li",[_._v("除非NAT路由器管理者预先设置了规则，否则送来的数据包将不能到达正确的目的地址")])])])]),_._v(" "),e("h2",{attrs:{id:"nat分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nat分类"}},[_._v("#")]),_._v(" NAT分类")]),_._v(" "),e("p",[_._v("假设一个内部主机"),e("code",[_._v("i.Addr")]),_._v("通过端口"),e("code",[_._v("iPort")]),_._v("向外部主机"),e("code",[_._v("s.Addr")]),_._v("的端口"),e("code",[_._v("sPort")]),_._v("发送请求，它们之间有一个NAT，将"),e("code",[_._v("i.Addr:iPort")]),_._v("转换为了"),e("code",[_._v("e.Addr:ePort")]),_._v("。")]),_._v(" "),e("Mermaid",{attrs:{id:"mermaid_382ee1a3",graph:_.$dataBlock.mermaid_382ee1a3}}),e("h3",{attrs:{id:"静态nat-static-nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态nat-static-nat"}},[_._v("#")]),_._v(" 静态NAT(Static NAT)")]),_._v(" "),e("ul",[e("li",[_._v("一个局域网对外有多个"),e("code",[_._v("e.Addr")])]),_._v(" "),e("li",[e("code",[_._v("i.Addr")]),_._v("和"),e("code",[_._v("e.Addr")]),_._v("一一对应")]),_._v(" "),e("li",[_._v("每个"),e("code",[_._v("i.Addr")]),_._v("都固定分配一个"),e("code",[_._v("e.Addr")])])]),_._v(" "),e("p",[_._v("最古老的NAT方法。")]),_._v(" "),e("ul",[e("li",[_._v("每个访问外网的主机都必须固定分配一个外网IP")]),_._v(" "),e("li",[_._v("只有分配了外网IP的主机才能访问外网，其他主机不能访问外网。")])]),_._v(" "),e("h3",{attrs:{id:"基本nat-动态nat-basic-nat-dynamic-nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本nat-动态nat-basic-nat-dynamic-nat"}},[_._v("#")]),_._v(" 基本NAT/动态NAT(Basic NAT/Dynamic NAT)")]),_._v(" "),e("ul",[e("li",[_._v("一个局域网对外有多个"),e("code",[_._v("e.Addr")])]),_._v(" "),e("li",[e("code",[_._v("i.Addr")]),_._v("和"),e("code",[_._v("e.Addr")]),_._v("一一对应")]),_._v(" "),e("li",[_._v("NAT程序维护一个可用IP池，用于动态分配"),e("code",[_._v("e.Addr")])]),_._v(" "),e("li",[_._v("只有"),e("code",[_._v("i.Addr")]),_._v("要访问外网时才给分配"),e("code",[_._v("e.Addr")])])]),_._v(" "),e("p",[_._v("这种方法也非常古老，现在用的不多。")]),_._v(" "),e("ul",[e("li",[_._v("IP地址按需取用，比静态NAT更节约IP地址")])]),_._v(" "),e("h3",{attrs:{id:"网络地址端口转换-napt"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络地址端口转换-napt"}},[_._v("#")]),_._v(" 网络地址端口转换(NAPT)")]),_._v(" "),e("ul",[e("li",[_._v("一个局域网对外只有一个"),e("code",[_._v("e.Addr")])]),_._v(" "),e("li",[e("code",[_._v("i.Addr:iPort")]),_._v("和"),e("code",[_._v("e.Addr:ePort")]),_._v("对应")]),_._v(" "),e("li",[_._v("只需要一个"),e("code",[_._v("e.Addr")]),_._v("IP地址即可运行，不需要IP池")])]),_._v(" "),e("p",[_._v("NAPT是现在常用的技术。")]),_._v(" "),e("ul",[e("li",[_._v("IP地址只需要一个，对外端口按需取用，IP地址节约到极致")])]),_._v(" "),e("h4",{attrs:{id:"完全圆锥型nat-full-cone-nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#完全圆锥型nat-full-cone-nat"}},[_._v("#")]),_._v(" 完全圆锥型NAT(Full cone NAT)")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("i.Addr:iPort")]),_._v("和"),e("code",[_._v("ePort")]),_._v("一一对应")]),_._v(" "),e("li",[_._v("所有发自"),e("code",[_._v("i.Addr:iPort")]),_._v("的数据包都经由"),e("code",[_._v("e.Addr:ePort")]),_._v("向外发送")]),_._v(" "),e("li",[_._v("任意外部主机向"),e("code",[_._v("e.Addr:ePort")]),_._v("发送数据包都能到达"),e("code",[_._v("i.Addr:iPort")])])]),_._v(" "),e("p",[e("img",{attrs:{src:t(614),alt:"Full cone NAT"}})]),_._v(" "),e("h4",{attrs:{id:"受限圆锥型nat-address-restricted-cone-nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#受限圆锥型nat-address-restricted-cone-nat"}},[_._v("#")]),_._v(" 受限圆锥型NAT((Address-)Restricted cone NAT)")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("i.Addr:iPort")]),_._v("和"),e("code",[_._v("ePort")]),_._v("一一对应")]),_._v(" "),e("li",[_._v("所有发自"),e("code",[_._v("i.Addr:iPort")]),_._v("的数据包都经由"),e("code",[_._v("e.Addr:ePort")]),_._v("向外发送")]),_._v(" "),e("li",[_._v("只有"),e("code",[_._v("s.Addr")]),_._v("上的任意端口向"),e("code",[_._v("e.Addr:ePort")]),_._v("发送数据包才能到达"),e("code",[_._v("i.Addr:iPort")])])]),_._v(" "),e("p",[e("img",{attrs:{src:t(615),alt:"(Address-)Restricted cone NAT"}})]),_._v(" "),e("h4",{attrs:{id:"端口受限圆锥型nat-port-restricted-cone-nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#端口受限圆锥型nat-port-restricted-cone-nat"}},[_._v("#")]),_._v(" 端口受限圆锥型NAT(Port-Restricted cone NAT)")]),_._v(" "),e("ul",[e("li",[e("code",[_._v("i.Addr:iPort")]),_._v("和"),e("code",[_._v("ePort")]),_._v("一一对应")]),_._v(" "),e("li",[_._v("所有发自"),e("code",[_._v("i.Addr:iPort")]),_._v("的数据包都经由"),e("code",[_._v("e.Addr:ePort")]),_._v("向外发送")]),_._v(" "),e("li",[_._v("只有"),e("code",[_._v("s.Addr:sPort")]),_._v("向"),e("code",[_._v("e.Addr:ePort")]),_._v("发送数据包才能到达"),e("code",[_._v("i.Addr:iPort")])])]),_._v(" "),e("p",[e("img",{attrs:{src:t(616),alt:"Port-Restricted cone NAT"}})]),_._v(" "),e("h4",{attrs:{id:"对称nat-symmetric-nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对称nat-symmetric-nat"}},[_._v("#")]),_._v(" 对称NAT(Symmetric NAT)")]),_._v(" "),e("ul",[e("li",[_._v("同一个"),e("code",[_._v("i.Addr:iPort")]),_._v("到不同的"),e("code",[_._v("s.Addr:sPort")]),_._v("都各自对应一个"),e("code",[_._v("ePort")])]),_._v(" "),e("li",[_._v("所有发自"),e("code",[_._v("i.Addr:iPort")]),_._v("且到达"),e("code",[_._v("s.Addr:sPort")]),_._v("的数据包都经由"),e("code",[_._v("e.Addr:ePort")]),_._v("向外发送")]),_._v(" "),e("li",[_._v("只有"),e("code",[_._v("s.Addr:sPort")]),_._v("向"),e("code",[_._v("e.Addr:ePort")]),_._v("发送数据包才能到达"),e("code",[_._v("i.Addr:iPort")])])]),_._v(" "),e("p",[e("img",{attrs:{src:t(617),alt:"Symmetric NAT"}})]),_._v(" "),e("h2",{attrs:{id:"nat穿透方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nat穿透方法"}},[_._v("#")]),_._v(" NAT穿透方法")]),_._v(" "),e("h3",{attrs:{id:"stun-simple-traversal-of-user-datagram-protocol-through-network-address-translators"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stun-simple-traversal-of-user-datagram-protocol-through-network-address-translators"}},[_._v("#")]),_._v(" STUN(Simple Traversal of User Datagram Protocol Through Network Address Translators)")]),_._v(" "),e("p",[_._v("STUN协议主要针对通信双方都在NAT后的情况，需要一个通信双方都能访问到的STUN服务器协调双方的通信。")]),_._v(" "),e("p",[_._v("假定一个STUN服务器位于公网上，IP地址为"),e("code",[_._v("s.Addr")]),_._v("，STUN服务端应用程序监听于默认端口3478；"),e("code",[_._v("Host_1")]),_._v("和"),e("code",[_._v("Host_2")]),_._v("分别位于两个NAT后，其内网IP地址正巧都一样是"),e("code",[_._v("i.Addr")]),_._v("，它们都运行这STUN客户端，都通过端口"),e("code",[_._v("iPort")]),_._v("与STUN服务器持续通信。而经过NAT后，STUN服务器看到的它们建立连接的IP地址和端口分别是"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("和"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("。")]),_._v(" "),e("Mermaid",{attrs:{id:"mermaid_64a56864",graph:_.$dataBlock.mermaid_64a56864}}),e("p",[_._v("在实际的通信开始前，STUN服务器会维护一个主机->IP+端口的表，例如上面这种情况下，表格中就会有"),e("code",[_._v("Host_1->e.1.Addr:e1Port")]),_._v("和"),e("code",[_._v("Host_2->e.2.Addr:e2Port")]),_._v("两项。")]),_._v(" "),e("p",[_._v("若假定"),e("code",[_._v("Host_1")]),_._v("想向"),e("code",[_._v("Host_2")]),_._v("发送一条信息。显然，"),e("strong",[_._v("不管NAT1是哪种模式，都不影响"),e("code",[_._v("Host_1")]),_._v("出站流量")]),_._v("，"),e("code",[_._v("Host_1")]),_._v("发送的数据包能正常出站。因此，关键问题就在于，数据包离开了NAT1之后，如何经过NAT2到达"),e("code",[_._v("Host_2")]),_._v("。")]),_._v(" "),e("p",[_._v("根据前文所述，NAT2可能采用了上述四种模式之一，不同的模式下STUN的处理方式不尽相同。在开始通信前，STUN客户端和服务器会通过一系列TCP和UDP包探测所处的NAT环境（探测方式很简单，稍微想想就能懂，在不济看看不同NAT环境下的运行过程也能想到对应的探测方法）。")]),_._v(" "),e("h5",{attrs:{id:"直接向host-2的ip地址发送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接向host-2的ip地址发送"}},[_._v("#")]),_._v(" 直接向"),e("code",[_._v("Host_2")]),_._v("的IP地址发送")]),_._v(" "),e("p",[_._v("当"),e("code",[_._v("Host_1")]),_._v("要发信息给"),e("code",[_._v("Host_2")]),_._v("的"),e("code",[_._v("jPort")]),_._v("时：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("Host_1")]),_._v("上的客户端向STUN服务器查询"),e("code",[_._v("Host_2")]),_._v("此时的IP地址"),e("code",[_._v("e.2.Addr")])]),_._v(" "),e("li",[e("code",[_._v("Host_1")]),_._v("上的客户端直接将包发往"),e("code",[_._v("e.2.Addr:jPort")])])]),_._v(" "),e("p",[_._v("显然，这种方法"),e("strong",[_._v("要求到"),e("code",[_._v("e.2.Addr")]),_._v("任何端口的包都能到达"),e("code",[_._v("Host_2")])]),_._v("，因此只有在NAT2是基本NAT时才可用。")]),_._v(" "),e("h5",{attrs:{id:"直接向host-2在nat2对应的端口中发送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接向host-2在nat2对应的端口中发送"}},[_._v("#")]),_._v(" 直接向"),e("code",[_._v("Host_2")]),_._v("在NAT2对应的端口中发送")]),_._v(" "),e("p",[_._v("当"),e("code",[_._v("Host_1")]),_._v("要发信息给"),e("code",[_._v("Host_2")]),_._v("的"),e("code",[_._v("jPort")]),_._v("时：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("Host_1")]),_._v("上的客户端向STUN服务器查询"),e("code",[_._v("Host_2")]),_._v("此时的IP地址和端口"),e("code",[_._v("e.2.Addr:e2Port")])]),_._v(" "),e("li",[e("code",[_._v("Host_1")]),_._v("上的客户端将包进行一层封装，在载荷中注明真实目的端口为"),e("code",[_._v("jPort")]),_._v("，然后发往"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("（进而通过NAT2转到"),e("code",[_._v("i.Addr:iPort")]),_._v("）")]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("上监听于"),e("code",[_._v("iPort")]),_._v("的STUN客户端收到包后，从载荷中拆出真正的数据包和目的端口"),e("code",[_._v("jPort")])]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("上的客户端将包转发到"),e("code",[_._v("localhost:jPort")])])]),_._v(" "),e("p",[_._v("根据前面分析的NAT规则，当"),e("code",[_._v("Host_2")]),_._v("上的客户端向STUN服务器发包时，STUN服务器收到的包的源地址和端口"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("就是NAT2为"),e("code",[_._v("Host_2")]),_._v("开放的地址和端口，因此直接往"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("发包就能到达"),e("code",[_._v("Host_2")]),_._v("。")]),_._v(" "),e("p",[_._v("显然，这种方法"),e("strong",[_._v("要求从任何地址到"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("的包都能到达"),e("code",[_._v("Host_2")])]),_._v("，因此只有在NAT2是基本NAT或完全圆锥型NAT时才可用。")]),_._v(" "),e("h5",{attrs:{id:"host-2先往host-1发一个消息，host-1再向host-2对应的端口中发送"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#host-2先往host-1发一个消息，host-1再向host-2对应的端口中发送"}},[_._v("#")]),_._v(" "),e("code",[_._v("Host_2")]),_._v("先往"),e("code",[_._v("Host_1")]),_._v("发一个消息，"),e("code",[_._v("Host_1")]),_._v("再向"),e("code",[_._v("Host_2")]),_._v("对应的端口中发送")]),_._v(" "),e("p",[_._v("当"),e("code",[_._v("Host_1")]),_._v("要发信息给"),e("code",[_._v("Host_2")]),_._v("的"),e("code",[_._v("jPort")]),_._v("时：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("Host_1")]),_._v("通知STUN服务器：我要向"),e("code",[_._v("Host_2")]),_._v("发送消息")]),_._v(" "),e("li",[_._v("STUN服务器通过于"),e("code",[_._v("Host_2")]),_._v("的持续通信过程通知"),e("code",[_._v("Host_2")]),_._v("："),e("code",[_._v("Host_1")]),_._v("要连接你；同时附上服务器中记录的"),e("code",[_._v("Host_1")]),_._v("当前的地址和端口"),e("code",[_._v("e.1.Addr:e1Port")])]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("通过端口"),e("code",[_._v("iPort")]),_._v("向"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("发送任意信息")]),_._v(" "),e("li",[e("code",[_._v("Host_1")]),_._v("上的客户端将包进行一层封装，在载荷中注明真实目的端口为"),e("code",[_._v("jPort")]),_._v("，然后发往"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("（进而通过NAT2转到"),e("code",[_._v("i.Addr:iPort")]),_._v("）")]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("上监听于"),e("code",[_._v("iPort")]),_._v("的STUN客户端收到包后，从载荷中拆出真正的数据包和目的端口"),e("code",[_._v("jPort")])]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("上的客户端将包转发到"),e("code",[_._v("localhost:jPort")])])]),_._v(" "),e("p",[_._v("仔细一看，这种方法其实是欺骗了NAT2，让它以为"),e("code",[_._v("Host_2")]),_._v("在与"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("通信："),e("code",[_._v("Host_2")]),_._v("通过"),e("code",[_._v("iPort")]),_._v("向"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("发送的消息会在NAT2处变成通过"),e("code",[_._v("e2Port")]),_._v("向"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("发送了信息。进而，在受限圆锥型NAT和端口受限圆锥型NAT中，后续来自"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("的所有信息都能通过"),e("code",[_._v("e2Port")]),_._v("畅通无阻地到达"),e("code",[_._v("Host_1")]),_._v("的"),e("code",[_._v("iPort")]),_._v("端口。")]),_._v(" "),e("p",[_._v("因此这种方法在NAT2是基本NAT、完全圆锥型NAT、受限圆锥型NAT和端口受限圆锥型NAT时都可用。")]),_._v(" "),e("p",[_._v("对于对称型NAT，"),e("code",[_._v("Host_2")]),_._v("从"),e("code",[_._v("iPort")]),_._v("发送到"),e("code",[_._v("e.1.Addr:e1Port")]),_._v("的信息会被NAT2分到另一个端口"),e("code",[_._v("e3Port")]),_._v("，这时"),e("code",[_._v("Host_1")]),_._v("必须往"),e("code",[_._v("e.2.Addr:e3Port")]),_._v("发消息才能到达"),e("code",[_._v("Host_1")]),_._v("，但是，"),e("code",[_._v("e3Port")]),_._v("具体是哪个是由NAT路由器决定的，"),e("code",[_._v("Host_2")]),_._v("并不知道具体端口号，"),e("code",[_._v("Host_1")]),_._v("也只有在NAT1是基本NAT或完全圆锥型NAT时才能收到"),e("code",[_._v("Host_2")]),_._v("发来的任意信息得到源地址端口，所以，如果通信双方有一方是对称型NAT时，另一方必须是基本NAT或完全对称NAT，STUN才能运行。")]),_._v(" "),e("h3",{attrs:{id:"turn-traversal-using-relay-nat-：由服务器来转发包，适用于任何nat"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#turn-traversal-using-relay-nat-：由服务器来转发包，适用于任何nat"}},[_._v("#")]),_._v(" TURN(Traversal Using Relay NAT)：由服务器来转发包，适用于任何NAT")]),_._v(" "),e("p",[_._v("TURN是STUN的扩展，相比STUN多了由服务器来转发包的功能，从而能适应双方都是对称型NAT的环境。")]),_._v(" "),e("p",[_._v("当"),e("code",[_._v("Host_1")]),_._v("要发信息给"),e("code",[_._v("Host_2")]),_._v("的"),e("code",[_._v("jPort")]),_._v("时：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("Host_1")]),_._v("上的客户端将包进行一层封装，在载荷中注明真实目的为"),e("code",[_._v("Host_2")]),_._v("的"),e("code",[_._v("jPort")]),_._v("，然后发往服务器"),e("code",[_._v("s.Addr:3478")])]),_._v(" "),e("li",[_._v("STUN服务器拆包，得知这是要给"),e("code",[_._v("Host_2")]),_._v("的包，于是发往"),e("code",[_._v("e.2.Addr:e2Port")]),_._v("（进而通过NAT2转到"),e("code",[_._v("i.Addr:iPort")]),_._v("）")]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("上监听于"),e("code",[_._v("iPort")]),_._v("的STUN客户端收到包后，从载荷中拆出真正的数据包和目的端口"),e("code",[_._v("jPort")])]),_._v(" "),e("li",[e("code",[_._v("Host_2")]),_._v("上的客户端将包转发到"),e("code",[_._v("localhost:jPort")])])]),_._v(" "),e("p",[_._v("这种方法完全由服务器进行包的转发，在NAT看来，就是"),e("code",[_._v("Host_2")]),_._v("一直在向一个服务器请求数据，与一般的HTTP等常用通信方式无异，因此在任何NAT环境下都可以使用。")]),_._v(" "),e("p",[_._v("和STUN相比，TURN主要的缺点就是所有流量都要走服务器，延迟高，且服务器负载很大。")]),_._v(" "),e("h3",{attrs:{id:"由内网主机控制端口映射规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#由内网主机控制端口映射规则"}},[_._v("#")]),_._v(" 由内网主机控制端口映射规则")]),_._v(" "),e("h4",{attrs:{id:"upnp-universal-plug-and-play-通用即插即用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#upnp-universal-plug-and-play-通用即插即用"}},[_._v("#")]),_._v(" UPnP(Universal Plug and Play, 通用即插即用)")]),_._v(" "),e("p",[_._v("UPnP 并不是周边设备即插即用模型的简单扩展。在设计上，它支持0设置、网络连接过程“不可见”和自动查找众多供应商提供的多如繁星的设备的类型。换言之，一个 UPnP 设备能够自动跟一个网络连接上、并自动获得一个 IP 地址、广播自己的功能并获悉其它已经连接上的设备及其功能。最后，此设备能自动顺利地切断网络连接，并且不会引起意想不到的问题。")]),_._v(" "),e("p",[e("img",{attrs:{src:t(618),alt:"UPnP"}})]),_._v(" "),e("ul",[e("li",[_._v("HTTPU和HTTPMU是在UDP协议上实现的HTTP协议")]),_._v(" "),e("li",[_._v("SSDP、GENA、SOAP指的是保存在XML文件中的数据格式")]),_._v(" "),e("li",[_._v("UPnP Device Architecture 仅仅是一个抽象的、公用的设备模型。任何UPnP设备都必须使用这一层")]),_._v(" "),e("li",[_._v("UPnP Forum 是UPnP论坛的各个专业委员会的设备定义层，在这个论坛中，不同电器设备由不同的专业委员会定义，，例如：电视委员会只负责定义网络电视设备部分，空调器委员会只负责定义网络空调设备部分等")]),_._v(" "),e("li",[_._v("UPnP Vendor 的信息是由设备制造厂商来“填充” 的，这部分一般有设备厂商提供的、对设备控制和操作的底层代码，然后，就是名称序列号呀，厂商信息之类的东西")])]),_._v(" "),e("p",[e("img",{attrs:{src:t(619),alt:"UPnP"}})]),_._v(" "),e("ul",[e("li",[_._v("发现：SSDP(Simple Service Discovery Protocol, 简单发现协议)\n"),e("ul",[e("li",[_._v("当一个控制点（客户端）接入网络的时候，它可以向一个特定的多播地址的SSDP端口使用M-SEARCH方法发送“ssdp:discover”消息。当设备监听到这个保留的多播地址上由控制点发送的消息的时候，设备会分析控制点请求的服务，如果自身提供了控制点请求的服务，设备将通过单播的方式直接响应控制点的请求。")]),_._v(" "),e("li",[_._v("当一个设备计划从网络上卸载的时候，它也应当向一个特定的多播地址的SSDP端口使用NOTIFY方法发送“ssdp:byebye”消息。\n"),e("ul",[e("li",[_._v("但是，即使没有发送“ssdp:byebye”消息，控制点也会根据“ssdp:alive”消息指定的超时值，将超时并且没有再次收到的“ssdp:alive”消息对应的设备认为是失效的设备。")])])]),_._v(" "),e("li",[_._v("在IPv4环境，当需要使用多播方式传送相关消息的时候，SSDP一般使用多播地址239.255.255.250和UDP端口号1900。")]),_._v(" "),e("li",[_._v("根据互联网地址指派机构的指派，SSDP在IPv6环境下使用多播地址FF0X::C，这里的X根据scope的不同可以有不同的取值。")])])]),_._v(" "),e("li",[_._v("控制：SOAP(Simple Object Access Protocol, 简单对象访问协议)\n"),e("ul",[e("li",[_._v("SOAP只指定了XML文件的格式，具体的内容格式由UPnP Forum和UPnP Vendor设备厂商自行指定，UPnP也因此非常自由")]),_._v(" "),e("li",[_._v("SOAP是交换数据的一种协议规范，使用在计算机网络Web服务中，交换带结构的信息。SOAP为了简化网页服务器从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。")])])]),_._v(" "),e("li",[_._v("事件：GENA(Generic Event Notification Architecture, 普通事件通知体系)\n"),e("ul",[e("li",[_._v("事件系统用于描述一个服务状态的描述变化。")])])])]),_._v(" "),e("p",[_._v("UPnP能控制设备，当然也包括路由器设备")]),_._v(" "),e("h4",{attrs:{id:"igd-internet-gateway-device-互联网网关设备协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#igd-internet-gateway-device-互联网网关设备协议"}},[_._v("#")]),_._v(" IGD(Internet Gateway Device, 互联网网关设备协议)")]),_._v(" "),e("p",[_._v("IGD就是基于UPnP控制互联网网关设备的协议。互联网网关设备就是UPnP Forum层定义的设备之一。")]),_._v(" "),e("p",[_._v("IGD在内网主机的客户端侧有如下功能：")]),_._v(" "),e("ul",[e("li",[_._v("获知公网（外部）IP地址")]),_._v(" "),e("li",[_._v("请求一个新的公网IP地址")]),_._v(" "),e("li",[_._v("列举现有的端口映射")]),_._v(" "),e("li",[_._v("添加和移除端口映射")]),_._v(" "),e("li",[_._v("给映射分配租赁时间")])]),_._v(" "),e("h3",{attrs:{id:"把端口映射情况直接告诉内网主机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#把端口映射情况直接告诉内网主机"}},[_._v("#")]),_._v(" 把端口映射情况直接告诉内网主机")]),_._v(" "),e("h4",{attrs:{id:"nat-pmp-nat-port-mapping-protocol-nat端口映射协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nat-pmp-nat-port-mapping-protocol-nat端口映射协议"}},[_._v("#")]),_._v(" NAT-PMP(NAT Port Mapping Protocol, NAT端口映射协议)")]),_._v(" "),e("p",[_._v("NAT-PMP是一个能自动创建网络地址转换（NAT）设置和端口映射配置而无需用户介入的网络协议。")]),_._v(" "),e("p",[_._v("NAT-PMP使用用户数据报协议（UDP），在5351端口运行。")]),_._v(" "),e("p",[_._v("NAT-PMP是PCP(端口控制协议)的前身。")]),_._v(" "),e("blockquote",[e("p",[_._v("2014年10月，Rapid7安全研究员Jon Hart公布，因厂商对NAT-PMP协议设计不当，估计公网上有1200万台网络设备受到NAT-PMP漏洞的影响。NAT-PMP协议的规范中特别指明，NAT网关不能接受来自外网的地址映射请求，但一些厂商的设计并未遵守此规定。黑客可能对这些设备进行恶意的端口映射，进行流量反弹、代理等攻击。")])]),_._v(" "),e("h4",{attrs:{id:"pcp-port-control-protocol-端口控制协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pcp-port-control-protocol-端口控制协议"}},[_._v("#")]),_._v(" PCP(Port Control Protocol, 端口控制协议)")]),_._v(" "),e("p",[_._v("许多 ISP 用户的应用程序必须可以通过 Internet 访问（例如，物联网设备、通过网络提供监视的IP摄像机等）。满足此要求的一种方法是创建大规模的静态NAT端口映射。但对于大量用户来说，创建静态NAT端口映射并不是一个可行的解决方案。")]),_._v(" "),e("p",[_._v("端口控制协议(PCP)使内网设备能够为自己和/或其他第三方设备请求特定的NAT端口映射，由NAT设备创建端口映射并将其反馈给内网设备。内网设备于是可以向互联网上的远程设备发送返回的"),e("code",[_._v("公网IP地址:端口")]),_._v("信息，从而使用户可以连接到设备。")]),_._v(" "),e("h4",{attrs:{id:"rsip-realm-specific-ip-特定域ip"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rsip-realm-specific-ip-特定域ip"}},[_._v("#")]),_._v(" RSIP(Realm Specific IP, 特定域IP)")]),_._v(" "),e("p",[e("strong",[_._v("RSIP旨在替代NAT")]),_._v("，保持NAT节约IPv4地址的特性，同时保证数据包的端到端完整性。")]),_._v(" "),e("p",[_._v("在RSIP模式下，内网主机访问外网时：")]),_._v(" "),e("ol",[e("li",[e("code",[_._v("i.Addr")]),_._v("主机上的RSIP客户端请求向RSIP网关发起请求")]),_._v(" "),e("li",[_._v("RSIP网关提供一个公网IP"),e("code",[_._v("e.Addr")]),_._v("或一个公网IP+一组端口号"),e("code",[_._v("e.Addr:ePorts")])]),_._v(" "),e("li",[_._v("同时RSIP网关设置转发规则"),e("code",[_._v("e.Addr[:ePort] -> i.Addr")])]),_._v(" "),e("li",[_._v("于是，"),e("code",[_._v("i.Addr")]),_._v("就能以RSIP网关提供的IP"),e("code",[_._v("e.Addr")]),_._v("作为自己的IP在公网愉快的玩耍了")])]),_._v(" "),e("p",[_._v("仔细一看，RSIP和NAT的唯一的区别就是：")]),_._v(" "),e("ul",[e("li",[_._v("NAT内网主机访问公网时不知道自己的公网IP，也不知道端口会被转成哪个")]),_._v(" "),e("li",[_._v("RSIP内网主机访问公网时知道自己的公网IP，也知道端口的转换关系")])]),_._v(" "),e("h3",{attrs:{id:"让路由器修改ip数据包中的部分内容以使协议正常运行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#让路由器修改ip数据包中的部分内容以使协议正常运行"}},[_._v("#")]),_._v(" 让路由器修改IP数据包中的部分内容以使协议正常运行")]),_._v(" "),e("h4",{attrs:{id:"alg-application-layer-gateway-application-level-gateway-应用层网关-：针对载荷中包含ip地址而造成错误的协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#alg-application-layer-gateway-application-level-gateway-应用层网关-：针对载荷中包含ip地址而造成错误的协议"}},[_._v("#")]),_._v(" ALG(Application Layer Gateway/Application-Level Gateway, 应用层网关)：针对载荷中包含IP地址而造成错误的协议")]),_._v(" "),e("p",[_._v("ALG针对的场景是：")]),_._v(" "),e("ul",[e("li",[_._v("在某些协议中，不仅包头里有一个"),e("code",[_._v("i.Addr:iPort")]),_._v("，载荷里面还会有"),e("code",[_._v("i.Addr:jPort")])]),_._v(" "),e("li",[_._v("包接收方需要向"),e("code",[_._v("i.Addr:jPort")]),_._v("发包以进行后续的协议操作")])]),_._v(" "),e("p",[_._v("这种场景下存在的问题是：")]),_._v(" "),e("ul",[e("li",[_._v("NAT只能转换包头的地址和端口")]),_._v(" "),e("li",[_._v("载荷里的"),e("code",[_._v("j.Addr:jPort")]),_._v("显然是内网地址，包接收方无法向其建立连接")])]),_._v(" "),e("p",[_._v("ALG的思想是：")]),_._v(" "),e("ol",[e("li",[_._v("NAT路由器识别载荷中的"),e("code",[_._v("i.Addr:jPort")]),_._v("并将其转换成"),e("code",[_._v("e.Addr:fPort")])]),_._v(" "),e("li",[_._v("NAT路由器自动打开端口"),e("code",[_._v("fPort")]),_._v("，将其数据转发到"),e("code",[_._v("i.Addr:jPort")])])]),_._v(" "),e("p",[_._v("ALG支持的协议：FTP、H.323（包括RAS、H.225、H.245）、SIP、DNS、ILS、MSN/QQ、NBT、RTSP、SQLNET、TFTP等。")]),_._v(" "),e("h4",{attrs:{id:"sbc-session-border-controller-会话边界控制器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sbc-session-border-controller-会话边界控制器"}},[_._v("#")]),_._v(" SBC(Session Border Controller, 会话边界控制器)")]),_._v(" "),e("p",[_._v("SBC针对的场景和ALG类似，但其仅面向企业级VoIP应用：")]),_._v(" "),e("ul",[e("li",[_._v("VoIP协议的载荷中包含IP地址信息")]),_._v(" "),e("li",[_._v("通常企业中为了安全，在引入VoIP前势必已经建了很多NAT和防火墙")])]),_._v(" "),e("p",[_._v("这种场景下存在的问题是：")]),_._v(" "),e("ul",[e("li",[_._v("如果要使用ALG以让VoIP正常工作，就要对大量路由器和防火墙进行升级，费时费力还不安全")])]),_._v(" "),e("p",[_._v("SBC的思想是：")]),_._v(" "),e("ol",[e("li",[_._v("终端将IP-PBX/软交换等核心控制设备的地址设置为SBC Proxy的地址")]),_._v(" "),e("li",[_._v("终端注册到核心设备时，SBC创建相应的地址映射表项")]),_._v(" "),e("li",[_._v("当终端开始呼叫时，SBC修改相应的地址信息，将报文发送给真正的核心设备")]),_._v(" "),e("li",[_._v("所有的信令流、媒体流都可经过SBC进行转发，另外也可设置媒体流旁路")])]),_._v(" "),e("p",[_._v("仔细一看，这不就是个针对VoIP应用设计的反向代理吗。")]),_._v(" "),e("h3",{attrs:{id:"ice-interactive-connectivity-establishment-交互式连接创建"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ice-interactive-connectivity-establishment-交互式连接创建"}},[_._v("#")]),_._v(" ICE(Interactive Connectivity Establishment, 交互式连接创建)")]),_._v(" "),e("p",[_._v("ICE是一种框架而非协议：")]),_._v(" "),e("p",[_._v("ICE创建是由IETF的MMUSIC(多方多媒体会话控制)工作组开发出来的一种framework，可集成各种NAT穿透技术，如STUN、TURN、RSIP等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。")])],1)}),[],!1,null,null,null);"function"==typeof o&&o(r);v.default=r.exports}}]);