(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{835:function(a,t,v){"use strict";v.r(t);var _=v(4),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h2",{attrs:{id:"复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制"}},[a._v("#")]),a._v(" 复制")]),a._v(" "),v("p",[a._v("命令：SLAVEOF 主机IP地址 端口")]),a._v(" "),v("p",[a._v("👆在从机上输入此命令后，从机和主机的存储内容会保持同步")]),a._v(" "),v("h3",{attrs:{id:"旧版复制功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#旧版复制功能"}},[a._v("#")]),a._v(" 旧版复制功能")]),a._v(" "),v("p",[a._v("同步(sync)和命令传播(command propagate)")]),a._v(" "),v("h4",{attrs:{id:"同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[a._v("#")]),a._v(" 同步")]),a._v(" "),v("p",[a._v("SYNC指令")]),a._v(" "),v("ul",[v("li",[a._v("把主服务器的所有数据打包成RDB给从服务器载入")]),a._v(" "),v("li",[a._v("把载入数据这段时间内的主服务器进行过的所有写命令再发给从服务器")])]),a._v(" "),v("h4",{attrs:{id:"命令传播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#命令传播"}},[a._v("#")]),a._v(" 命令传播")]),a._v(" "),v("ul",[v("li",[a._v("把造成主从服务器不一致的修改命令发送给同步后的所有从服务器进行执行")])]),a._v(" "),v("h4",{attrs:{id:"缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺陷"}},[a._v("#")]),a._v(" 缺陷")]),a._v(" "),v("p",[a._v("断线后重连要重新执行同步，但是如果断线时间不长的话没有必要再次同步（因为大部分数据都还是一样的）")]),a._v(" "),v("h3",{attrs:{id:"新版复制功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新版复制功能"}},[a._v("#")]),a._v(" 新版复制功能")]),a._v(" "),v("p",[a._v("不一样的同步、一样的命令传播")]),a._v(" "),v("h4",{attrs:{id:"新版同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#新版同步"}},[a._v("#")]),a._v(" 新版同步")]),a._v(" "),v("p",[a._v("PSYNC指令")]),a._v(" "),v("p",[a._v("分为完整重同步(full resynchronization)和部分重同步(partial resynchronization)")]),a._v(" "),v("h5",{attrs:{id:"完整重同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#完整重同步"}},[a._v("#")]),a._v(" 完整重同步")]),a._v(" "),v("p",[a._v("同旧版的同步功能")]),a._v(" "),v("h5",{attrs:{id:"部分重同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#部分重同步"}},[a._v("#")]),a._v(" 部分重同步")]),a._v(" "),v("p",[a._v("专门用于处理断线重连的问题")]),a._v(" "),v("h6",{attrs:{id:"两个概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#两个概念"}},[a._v("#")]),a._v(" 两个概念")]),a._v(" "),v("ul",[v("li",[a._v("复制偏移量\n"),v("ul",[v("li",[a._v("执行复制的双方都各自维护一个复制偏移量，存储主服务器向从服务器进行命令传播的字节数")]),a._v(" "),v("li",[a._v("如果不掉线，主从服务器上的此偏移量始终相同")])])]),a._v(" "),v("li",[a._v("复制积压缓冲区\n"),v("ul",[v("li",[a._v("一个固定长度的FIFO队列，存储所有进行传播的指令")]),a._v(" "),v("li",[a._v("以偏移量标记")])])]),a._v(" "),v("li",[a._v("服务器运行ID\n"),v("ul",[v("li",[a._v("由主服务器指定，唯一标记每个从服务器")])])])]),a._v(" "),v("h3",{attrs:{id:"实现方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现方法"}},[a._v("#")]),a._v(" 实现方法")]),a._v(" "),v("ul",[v("li",[a._v("每秒发一次心跳数据检查复制偏移量，及时发现指令丢失")])]),a._v(" "),v("p",[a._v("断线重连之后：")]),a._v(" "),v("ul",[v("li",[a._v("先验证服务器运行ID，如果是一个新加的服务器就直接完整重同步")]),a._v(" "),v("li",[a._v("从服务器向主服务器发自己的复制偏移量")]),a._v(" "),v("li",[a._v("主服务器在复制积压缓冲区中找这个复制偏移量是否还存在")]),a._v(" "),v("li",[a._v("若存在则从此偏移量处发送复制积压缓冲区中的指令")]),a._v(" "),v("li",[a._v("否则执行完整重同步")])]),a._v(" "),v("h2",{attrs:{id:"sentinel"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sentinel"}},[a._v("#")]),a._v(" Sentinel")]),a._v(" "),v("p",[a._v("由一个或多个Sentinel实例(instance)组成的Sentinel系统可以监视任意多个主服务器，当被监视的主服务器掉线时，自动将主服务器下的某个从服务器提升为主服务器。")]),a._v(" "),v("p",[a._v("这是Redis的高可用性(high availability)解决方案。")]),a._v(" "),v("h2",{attrs:{id:"集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[a._v("#")]),a._v(" 集群")]),a._v(" "),v("p",[a._v("使用切片的方法将一个数据库分布到多个Redis节点中")]),a._v(" "),v("p",[a._v("在集群中的某个节点进行查找时，如果在当前就有结果，则返回，否则计算key属于哪个节点")])])}),[],!1,null,null,null);t.default=s.exports}}]);