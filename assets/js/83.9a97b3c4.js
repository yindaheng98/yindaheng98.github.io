(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{746:function(e,t,s){"use strict";s.r(t);var r=s(4),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"kubernetes是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes是什么"}},[e._v("#")]),e._v(" Kubernetes是什么")]),e._v(" "),s("p",[e._v("Kubernetes简称k8s，是一种容器编排工具，可以看作是docker-compose的强化版。")]),e._v(" "),s("blockquote",[s("p",[e._v("通过现代的 Web 服务，用户希望应用程序能够 24/7 全天候使用，开发人员希望每天可以多次发布部署新版本的应用程序。 容器化可以帮助软件包达成这些目标，使应用程序能够以简单快速的方式发布和更新，而无需停机。Kubernetes 帮助您确保这些容器化的应用程序在您想要的时间和地点运行，并帮助应用程序找到它们需要的资源和工具。")])]),e._v(" "),s("h2",{attrs:{id:"本文结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本文结构"}},[e._v("#")]),e._v(" 本文结构")]),e._v(" "),s("ol",[s("li",[e._v("按照k8s的系统层次：Cluster > Node > Pod介绍k8s的系统架构层次")]),e._v(" "),s("li",[e._v("按照k8s管理层次Service > < Deployments介绍k8s的容器管理方法")])]),e._v(" "),s("h2",{attrs:{id:"k8s系统架构层次"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#k8s系统架构层次"}},[e._v("#")]),e._v(" k8s系统架构层次")]),e._v(" "),s("h3",{attrs:{id:"集群-cluster"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集群-cluster"}},[e._v("#")]),e._v(" 集群 Cluster")]),e._v(" "),s("p",[s("strong",[e._v("Kubernetes用于协调高度可用的计算机集群，这些计算机集群被连接作为单个单元工作。")]),e._v(" Kubernetes 的抽象性允许您将容器化的应用程序部署到集群，而不必专门将其绑定到单个计算机。Kubernetes 负责在一个集群上自动分发和调度容器应用程序。一个典型的集群结构如下图：")]),e._v(" "),s("p",[s("img",{attrs:{src:"i/module_01_cluster.png",alt:"典型集群结构"}})]),e._v(" "),s("p",[e._v("其中：")]),e._v(" "),s("ul",[s("li",[e._v("“Master”：负责管理集群。协调集群中的所有活动，例如调度应用程序、维护应用程序的所需状态、扩展应用程序和滚动更新；")]),e._v(" "),s("li",[e._v("“Node”：集群中的工作机器，见下节介绍。")])]),e._v(" "),s("h3",{attrs:{id:"节点-node"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#节点-node"}},[e._v("#")]),e._v(" 节点 Node")]),e._v(" "),s("p",[e._v("集群中的工作机器，可以是"),s("strong",[e._v("物理机或虚拟机")]),e._v("，是应用程序容器的"),s("strong",[e._v("运行载体")]),e._v("。每个Node上都可以运行多个容器，Node上的容器划分为一个个“Pods”（见下节介绍）。比如下图是一个典型的包含了多个Pod的Node的内部结构：")]),e._v(" "),s("p",[s("img",{attrs:{src:"i/module_03_nodes.png",alt:"Node内部"}})]),e._v(" "),s("p",[e._v("每个Node至少运行以下组件：")]),e._v(" "),s("ul",[s("li",[e._v("Kubelet：负责Node与Master之间的通信，并管理机器上运行的Pod。")]),e._v(" "),s("li",[e._v("容器运行时(例如 Docker、rkt)：受Kubelet控制，负责从镜像仓库中拉取容器镜像，解包容器并运行应用程序。")])]),e._v(" "),s("h3",{attrs:{id:"应用程序实例-pod"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用程序实例-pod"}},[e._v("#")]),e._v(" 应用程序实例 Pod")]),e._v(" "),s("p",[e._v("Pod模型可以理解为应用程序特定的“"),s("strong",[e._v("逻辑主机")]),e._v("”，并且可以包含"),s("strong",[e._v("相对紧密耦合的不同应用程序容器")]),e._v("。例如，Pod 可能包含带有 Node.js 应用程序的容器以及另一个要吸收 Node.js Web 服务器提供的数据的不同容器。Pod 中的容器共享 IP 地址和端口空间，始终位于同一位置并且统一调度，并在相同的节点上运行，共享上下文环境。如图所示是一些大小不同的Pod：")]),e._v(" "),s("p",[s("img",{attrs:{src:"i/module_03_pods.png",alt:"各种Pod"}})]),e._v(" "),s("p",[e._v("Pod是Kubernetes平台上原子级别的单元，每个Pod在Kubernetes中都有一个唯一的 IP 地址，且能从Pod外部进行访问的容器端口由用户明确指定。当我们在Kubernetes上创建一个部署(Deployment)时，该部署将在其中创建包含容器的 Pod（而不是直接创建容器）。")]),e._v(" "),s("p",[e._v("（其实就相当于一个docker-compose，用户指定expose端口）")]),e._v(" "),s("h2",{attrs:{id:"k8s容器管理方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#k8s容器管理方法"}},[e._v("#")]),e._v(" k8s容器管理方法")]),e._v(" "),s("h3",{attrs:{id:"部署-deployment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#部署-deployment"}},[e._v("#")]),e._v(" 部署 Deployment")]),e._v(" "),s("p",[e._v("Deployment负责创建和更新Node中的应用程序实例。创建Deployment后， Master会将Deployment创建的应用程序实例调度到集群中的各个Node。")]),e._v(" "),s("p",[e._v("创建应用程序实例后，Kubernetes 部署控制器会持续监视这些实例。如果托管它的节点不可用或删除，则部署控制器将替换实例。 这提供了一种解决机器故障或维护的自愈机制。")]),e._v(" "),s("blockquote",[s("p",[e._v("在“编排”诞生前的世界中，通常会使用安装脚本启动应用程序，但是它们并不能从机器故障中恢复。通过创建应用程序实例并使其运行在跨节点的机器之间，Kubernetes部署提供了截然不同的应用管理方法。")])]),e._v(" "),s("h3",{attrs:{id:"服务-service"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务-service"}},[e._v("#")]),e._v(" 服务 Service")]),e._v(" "),s("p",[e._v("在逻辑上，Deployment是以Service为单位进行的。如图所示：")]),e._v(" "),s("p",[s("img",{attrs:{src:"i/module_04_services.png",alt:"典型集群部署"}})]),e._v(" "),s("p",[e._v("每个Service和每个Deployment一一对应，而一个Service可能包含多个Node中的多个Pods。")]),e._v(" "),s("p",[e._v("Kubernetes中的Service是一个"),s("strong",[e._v("抽象对象")]),e._v("，它"),s("strong",[e._v("定义了一组逻辑的Pods和一个访问它们的策略")]),e._v("，是允许Pod在Kubernetes中死亡和复制而不影响应用程序的抽象层。Service处理Pod之间的发现和路由(如应用程序中的前端和后端组件)，让"),s("strong",[e._v("互相依赖的Pod之间的耦合松动")]),e._v("。")]),e._v(" "),s("p",[e._v("服务像所有Kubernetes对象一样，由YAML(首选)或JSON定义。针对服务的一组Pod在配置文件中通常由LabelSelector确定。虽然每个Pod都有一个唯一的IP地址，但是这些IP不会在没有服务的情况下公开在Cluster之外。服务允许您的应用程序接收流量。可以通过在配置文件中指定ServiceSpec类型以不同方式显示服务：")]),e._v(" "),s("ul",[s("li",[e._v("ClusterIP(默认)：在集群中的内部IP上公开服务。此类型使服务只能从集群中访问")]),e._v(" "),s("li",[e._v("NodePort：使用NAT在群集中每个选定的节点的同一端口上显示该服务。使用"),s("code",[e._v(":")]),e._v("可以从群集外部访问服务。建立ClusterIP的超集")]),e._v(" "),s("li",[e._v("LoadBalancer：在当前云中创建外部负载平衡器(如果支持)，并为服务分配固定的外部IP。建立NodePort的超集")]),e._v(" "),s("li",[e._v("ExternalName：使用任意名称显示该服务(由规范中的externalName指定)，本过程通过使用该名称返回CNAME记录达成。无须使用代理。这种类型需要v1.7或更高版本的kube-dns")])]),e._v(" "),s("h3",{attrs:{id:"服务和标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务和标签"}},[e._v("#")]),e._v(" 服务和标签")]),e._v(" "),s("p",[e._v("服务使用 标签和选择器，匹配一组 Pod，成为分组原语，此原语允许在 Kubernetes 中的对象进行逻辑运算。 标签是一对附加到对象的键/值对，可以以多种方式使用，方式如下:")]),e._v(" "),s("ul",[s("li",[e._v("指定用于开发、测试和生产的对象")]),e._v(" "),s("li",[e._v("嵌入版本标签")]),e._v(" "),s("li",[e._v("使用标签分类对象")])]),e._v(" "),s("p",[s("img",{attrs:{src:"i/module_04_labels.png",alt:"服务和标签"}})]),e._v(" "),s("h2",{attrs:{id:"k8s教程中出现的几个软件的简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#k8s教程中出现的几个软件的简介"}},[e._v("#")]),e._v(" k8s教程中出现的几个软件的简介")]),e._v(" "),s("h3",{attrs:{id:"kubernetes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes"}},[e._v("#")]),e._v(" Kubernetes")]),e._v(" "),s("p",[e._v("一系列管理工具、API以及协议的集合")]),e._v(" "),s("h3",{attrs:{id:"minikube"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#minikube"}},[e._v("#")]),e._v(" Minikube")]),e._v(" "),s("p",[e._v("k8s的一种实现，可以看作是一种集群管理的服务端")]),e._v(" "),s("h3",{attrs:{id:"kubectl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kubectl"}},[e._v("#")]),e._v(" Kubectl")]),e._v(" "),s("p",[e._v("使用 Kubernetes API 与集群进行交互，可以看作是集群管理的客户端")]),e._v(" "),s("p",[e._v("下一篇："),s("RouterLink",{attrs:{to:"/Kubernetes/Kubernetes使用.html"}},[e._v("Kubernetes(k8s)的安装和基本使用")])],1)])}),[],!1,null,null,null);t.default=v.exports}}]);