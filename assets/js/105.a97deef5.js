(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{774:function(t,r,e){"use strict";e.r(r);var a=e(4),s=Object(a.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("原文："),e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/87879447",target:"_blank",rel:"noopener noreferrer"}},[t._v("[WebRTC架构分析] WebRTC 实现的 RFC 知多少？(RTP/RTCP/FEC 相关)"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),e("p",[t._v("WebRTC 作为一个多媒体实时通信系统，实现了很多 RFC 标准，并且针对 WebRTC 本身也制定了相关的标准。要想对 WebRTC 做深入的了解，参考相关标准文献是必不可少的，否则一头扎进源码去分析具体实现逻辑，很难达到预期的效果。如果阅读了相关文献，从基础理论上有一个宏观上的认识，那么再去分析相关源码，你会时不时有“原来是这样”的感叹。")]),t._v(" "),e("p",[t._v("本人在分析源码的过程中参考一系列的 RFC 文档，计划通过几篇文章对相关 RFC 文档做一个整理、分类，并且做出简要介绍。")]),t._v(" "),e("p",[t._v("归纳起来，WebRFC 实现参考的 RFC 标准分如下几类：")]),t._v(" "),e("ul",[e("li",[t._v("ICE 协议相关部分，媒体描述，offer/answer 通信过程。")]),t._v(" "),e("li",[t._v("P2P 穿越相关部分，建立一对一通信链路。")]),t._v(" "),e("li",[t._v("DTLS 相关部分，主要是网络传输相关标准。")]),t._v(" "),e("li",[t._v("RTP/RTCP/FEC 相关部分，主要是多媒体传输相关标准。")])]),t._v(" "),e("p",[t._v("另外，WebRTC 是作为浏览器内核发布的，对外提供的是 JavaScript 接口，所以有一套 JSEP 规范，暂且没有分析计划。")]),t._v(" "),e("p",[t._v("第一篇我们就介绍 RTP/RTCP/FEC 相关部分。")]),t._v(" "),e("h2",{attrs:{id:"rfc-1889"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-1889"}},[t._v("#")]),t._v(" RFC 1889")]),t._v(" "),e("p",[t._v("此协议主要是描述了 RTP real-time transport protocol。RTP 协议主要是用于多人音视频会议的应用场景下。协议内定义了 RTP、RTCP 的基本报文格式和最初的算法。")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc1889",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-3550"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-3550"}},[t._v("#")]),t._v(" RFC 3550")]),t._v(" "),e("p",[t._v("RFC 3550 是在 RFC 1889 的基础上进行了改进， 对 RTP 包头，RTCP 的 SR、RR、SDES、APP、BYE 做了介绍，对 RTCP 报文的收发算法、RTT 的计算做了规定。")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc3550",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-3551-rtp-avp"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-3551-rtp-avp"}},[t._v("#")]),t._v(" RFC 3551 RTP/AVP")]),t._v(" "),e("p",[t._v("RFC 3551 叫做 RTP Audio visual profile，是 RFC 3550 的补充，主要体现在以下几方面：")]),t._v(" "),e("ol",[e("li",[t._v("对 RTP/RTCP 头没有变化。对 RTCP 数据包发送时间周期做了补充说明。")]),t._v(" "),e("li",[t._v("对 AV codec 对应的 payload type 做了说明，历史上采用"),e("strong",[t._v("静态 payload type")]),t._v(" 并且和 name 绑定，后来发现 payload type 空间很有限，所以鼓励用"),e("strong",[t._v("动态 payload type")]),t._v("，范围是 96-127。")]),t._v(" "),e("li",[t._v("对音频、视频 codec 做了一个说明，这些都是比较老的格式。")])]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc3551",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-4585-rtp-avpf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-4585-rtp-avpf"}},[t._v("#")]),t._v(" rfc 4585 RTP/AVPF")]),t._v(" "),e("p",[t._v("RFC 4585 叫做 RTP/RTCP Audio visual profile based feedback。在 RFC 3550 和 RFC 3551 的基础上，提供了反馈消息的机制(Feedback message)。")]),t._v(" "),e("ul",[e("li",[t._v("提出了反馈基于三个层面的概念：")])]),t._v(" "),e("ol",[e("li",[t._v("Transport layer feedback RTPFB 205")]),t._v(" "),e("li",[t._v("Payload-specific feedback PSFB 206")]),t._v(" "),e("li",[t._v("Application layer feedback")])]),t._v(" "),e("ul",[e("li",[t._v("定义了反馈消息的通用格式如下。")]),t._v(" "),e("li",[t._v("定义了基于 Transport layer 的 NACK 反馈机制。")]),t._v(" "),e("li",[t._v("定义了基于 Payload-specific")])]),t._v(" "),e("ol",[e("li",[t._v("PLI(Picture Loss Indication) 丢帧请求。")]),t._v(" "),e("li",[t._v("SLI(Slice Loss Indication) 丢片请求。")]),t._v(" "),e("li",[t._v("RPSI(Reference Picture Selection Indication) 参考帧选择指示器。")])]),t._v(" "),e("p",[t._v("对消息在 SDP 中的属性也做了说明。属性表示是 “a=rtcp-fb:”，比如：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("a=rtcp-fb:101 nack\na=rtcp-fb:101 nack pli\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])]),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc4585",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-5104"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-5104"}},[t._v("#")]),t._v(" RFC 5104")]),t._v(" "),e("p",[t._v("RFC 4885 中只是定义了简单的反馈机制，比如 NACK。是适合于 P2P 通信模式，或者是小方多人会议模式。")]),t._v(" "),e("p",[t._v("RFC 5104 制定了更适合多人通信模式的相关反馈机制。")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc5104",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-5285"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-5285"}},[t._v("#")]),t._v(" RFC 5285")]),t._v(" "),e("p",[t._v("定义 RTP 中的扩展头。其实 RFC 3550 中也提供了扩展头规范，但是只能有一种扩展头类型，不够灵活。而 RFC 5285 支持多种类型扩展头。")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc5285",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-5761"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-5761"}},[t._v("#")]),t._v(" RFC 5761")]),t._v(" "),e("p",[t._v("解决 rtp 和 rtcp 共用同一个端口，数据包解复用的问题。这是通过 payload type 来解决。")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc5761",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("WebRTC 识别 RTCP 的方法，是按照 RFC 指示做的，如下：")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// Check the RTP payload type. If 63 &lt; payload type &lt; 96, it's RTCP.\n// For additional details, see http://tools.ietf.org/html/rfc5761.\nbool IsRtcpPacket(const char* data, size_t len) {\n  if (len &lt; 2) {\n    return false;\n  }\n  char pt = data[1] &amp; 0x7F;\n  return (63 &lt; pt) &amp;&amp; (pt &lt; 96);\n}\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("h2",{attrs:{id:"rfc-6184"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-6184"}},[t._v("#")]),t._v(" RFC 6184")]),t._v(" "),e("p",[t._v("此 RFC 主要是讲述了将 H.264 NALU 打包成 RTP 的规范。")]),t._v(" "),e("p",[t._v("webrtc 中实现了 single 模式和 STAP-A 模式。")]),t._v(" "),e("p",[t._v("也实现了将一个 NALU 分片的机制。")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc6184",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"rfc-2198"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-2198"}},[t._v("#")]),t._v(" RFC 2198")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc2198",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("此 RFC 主要讲述音频冗余。通过实践来看，网络拥塞、带宽限制等都会造成网络丢包，丢包是互联网音视频通信音频差的主要原因。引入冗余可以让接收端根据冗余数据恢复丢失的数据。")]),t._v(" "),e("p",[t._v("音频冗余相对简单，主要思想就是：发送的时候，一个当前要发送的新包(primary packet)携带几个已经发过的包（即，冗余包），组成的一个大包；接收端，收到此包以后，可以解开，得到多个包，如果其中的一个冗余包刚好是之前发送丢掉的，那么此时马上可以恢复出来，达到冗余效果。")]),t._v(" "),e("p",[t._v("带冗余的音频包，RTP 头还是当前新包的头，在 RTP 头后面加入冗余包头，冗余包头后面是冗余数据。注意，primary packet 的数据是在冗余数据的后面。")]),t._v(" "),e("p",[t._v("冗余包头格式如下:")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    0                   1                    2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |F|   block PT  |  timestamp offset         |   block length    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br")])]),e("p",[t._v("F: 一个bit，1表示后面还有冗余包，0 表示最后一个冗余头。")]),t._v(" "),e("p",[t._v("block PT: 冗余包 payload type")]),t._v(" "),e("p",[t._v("timestamp offset：相对于 primary 包的时间戳偏移量。")]),t._v(" "),e("p",[t._v("block length: 数据长度。")]),t._v(" "),e("p",[t._v("带冗余数据包的一个特点是：所有数据包的时间戳，不应该相同。因为相同毫无意义吧！")]),t._v(" "),e("h2",{attrs:{id:"rfc-2733"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-2733"}},[t._v("#")]),t._v(" RFC 2733")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc2733",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("此文档主要是讲 FEC ：Generic Forward Error Correction")]),t._v(" "),e("p",[t._v("文中讨论了 FEC 的主要解决的问题。如何通过原始媒体数据生成 FEC 数据包，FEC 数据包格式，如何通过 FEC 来恢复丢失的媒体包。")]),t._v(" "),e("p",[t._v("FEC 主要是采用 xor 运算来实现。")]),t._v(" "),e("h2",{attrs:{id:"rfc-5109"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rfc-5109"}},[t._v("#")]),t._v(" RFC 5109")]),t._v(" "),e("p",[t._v("链接："),e("a",{attrs:{href:"https://tools.ietf.org/html/rfc5109",target:"_blank",rel:"noopener noreferrer"}},[t._v("tools.ietf.org/html/rfc"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("此文也是讨论 FEC，理念是基于 RFC 2733，可以说是一个改进版本。")]),t._v(" "),e("p",[t._v("unequal error protection")]),t._v(" "),e("p",[t._v("Uneven Level Protection")]),t._v(" "),e("h2",{attrs:{id:"后记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后记"}},[t._v("#")]),t._v(" 后记")]),t._v(" "),e("p",[t._v("WebRTC rtp_rtcp 模块实现了大多数 RTP/RTCP/FEC 相关规范。所以学习本文整理的规范是进一步 rtp_rtcp 模块的基础。后续跟进情况，再决定是否更新。")])])}),[],!1,null,null,null);r.default=s.exports}}]);