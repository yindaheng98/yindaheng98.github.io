(window.webpackJsonp=window.webpackJsonp||[]).push([[278],{955:function(_,v,e){"use strict";e.r(v);var n=e(4),t=Object(n.a)({},(function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("p",[_._v("########################\n结构化您的工程\n########################")]),_._v(" "),e("p",[_._v(".. image:: https://farm5.staticflickr.com/4203/33907151224_0574e7dfc2_k_d.jpg")]),_._v(" "),e("p",[_._v("我们对于“结构化”的定义是您关注于怎样使您的项目最好地满足它的对象性，我们\n需要去考虑如何更好地利用Python的特性来创造简洁、高效的代码。在实践层面，\n“结构化”意味着通过编写简洁的代码，并且正如文件系统中文件和目录的组织一样，\n代码应该使逻辑和依赖清晰。")]),_._v(" "),e("p",[_._v("哪个函数应该放到哪个模块？数据在项目中如何流转？什么功能和函数应该组合\n或独立？要解决这些问题，您可以开始做一个计划，大体来说，即是您的最终产品\n看起来会是怎样的。")]),_._v(" "),e("p",[_._v("在这一章节中，我们更深入地去观察Python的模块和导入系统，因为它们是加强您\n的项目结构化的关键因素，接着我们会从不同层面去讨论如何去构建可扩展且测试\n可靠的代码。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("仓库的结构")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("这很重要\n:::::::::::::::")]),_._v(" "),e("p",[_._v("在一个健康的开发周期中，代码风格，API设计和自动化是非常关键的。同样的，对于工程的 "),e("code",[_._v("架构 <http://www.amazon.com/gp/product/1257638017/ref=as_li_ss_tl?ie=UTF8&tag=bookforkind-20&linkCode=as2&camp=1789&creative=39095&creativeASIN=1257638017>")]),_._v("_ ,仓库的结构也是关键的一部分。")]),_._v(" "),e("p",[_._v("当一个潜在的用户和贡献者登录到您的仓库页面时，他们会看到这些:")]),_._v(" "),e("ul",[e("li",[_._v("工程的名字")]),_._v(" "),e("li",[_._v("工程的描述")]),_._v(" "),e("li",[_._v("一系列的文件")])]),_._v(" "),e("p",[_._v("只有当他们滚动到目录下方时才会看到您工程的README。")]),_._v(" "),e("p",[_._v("如果您的仓库的目录是一团糟，没有清晰的结构，他们可能要到处寻找才能找到您写的漂亮的文档。")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("为您的渴望的事业而奋斗，而不是仅仅只为您现在的工作而工作。\n")])])]),e("p",[_._v("当然，第一印象并不是一切。但是，您和您的同事会和这个仓库并肩战斗很长时间，会熟悉它的每一个角落和细节。拥有良好的布局，事半功倍。")]),_._v(" "),e("p",[_._v("仓库样例\n:::::::::::::::::")]),_._v(" "),e("p",[e("strong",[_._v("请看这里")]),_._v(": 这是 "),e("code",[_._v("Kenneth Reitz在2013年推荐的 <https://www.kennethreitz.org/essays/repository-structure-and-python>")]),_._v("_ 。")]),_._v(" "),e("p",[_._v("这个仓库 "),e("code",[_._v("可以在GitHub上找到 <https://github.com/kennethreitz/samplemod>")]),_._v("__ 。")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("README.rst\nLICENSE\nsetup.py\nrequirements.txt\nsample/__init__.py\nsample/core.py\nsample/helpers.py\ndocs/conf.py\ndocs/index.rst\ntests/test_basic.py\ntests/test_advanced.py\n")])])]),e("p",[_._v("让我们看一下细节。")]),_._v(" "),e("p",[_._v("真正的模块\n:::::::::::::::::")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./sample/")]),_._v(" or "),e("code",[_._v("./sample.py")]),_._v('"\n"作用", "核心代码"')]),_._v(" "),e("p",[_._v("您的模块包是这个仓库的核心，它不应该隐藏起来:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("./sample/\n")])])]),e("p",[_._v("如果您的模块只有一个文件，那么您可以直接将这个文件放在仓库的根目录下:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("./sample.py\n")])])]),e("p",[_._v("这个模块文件不应该属于任何一个模棱两可的src或者python子目录。")]),_._v(" "),e("p",[_._v("License\n:::::::")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./LICENSE")]),_._v('"\n"作用", "许可证."')]),_._v(" "),e("p",[_._v("除了源代码本身以外，这个毫无疑问是您仓库最重要的一部分。在这个文件中要有完整的许可说明和授权。")]),_._v(" "),e("p",[_._v("如果您不太清楚您应该使用哪种许可方式，请查看 "),e("code",[_._v("choosealicense.com <http://choosealicense.com>")]),_._v("_.")]),_._v(" "),e("p",[_._v("当然，您也可以在发布您的代码时不做任何许可说明，但是这显然阻碍潜在的用户使用您的代码。")]),_._v(" "),e("p",[_._v("Setup.py\n::::::::")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./setup.py")]),_._v('"\n"作用", "打包和发布管理"')]),_._v(" "),e("p",[_._v("如果您的模块包在您的根目录下，显然这个文件也应该在根目录下。")]),_._v(" "),e("p",[_._v("Requirements File\n:::::::::::::::::")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./requirements.txt")]),_._v('"\n"作用", "开发依赖."')]),_._v(" "),e("p",[_._v("一个 "),e("code",[_._v("pip requirements file <https://pip.pypa.io/en/stable/user_guide/#requirements-files>")]),_._v("__ 应该放在仓库的根目录。它应该指明完整工程的所有依赖包: 测试, 编译和文档生成。")]),_._v(" "),e("p",[_._v("如果您的工程没有任何开发依赖，或者您喜欢通过 "),e("code",[_._v("setup.py")]),_._v(" 来设置，那么这个文件不是必须的。")]),_._v(" "),e("p",[_._v("Documentation\n:::::::::::::")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./docs/")]),_._v('"\n"作用", "包的参考文档"')]),_._v(" "),e("p",[_._v("没有任何理由把这个放到别的地方。")]),_._v(" "),e("p",[_._v("Test Suite\n::::::::::")]),_._v(" "),e("p",[e("em",[_._v("想了解关于编写测试的建议，请查阅")]),_._v(" :doc:"),e("code",[_._v("/writing/tests")]),_._v("。")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./test_sample.py")]),_._v(" or "),e("code",[_._v("./tests")]),_._v('"\n"作用", "包的集合和单元测试"')]),_._v(" "),e("p",[_._v("最开始，一组测试例子只是放在一个文件当中:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("./test_sample.py\n")])])]),e("p",[_._v("当测试例子逐步增加时，您会把它放到一个目录里面，像下面这样:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("tests/test_basic.py\ntests/test_advanced.py\n")])])]),e("p",[_._v("当然，这些测试例子需要导入您的包来进行测试，有几种方式来处理:")]),_._v(" "),e("ul",[e("li",[_._v("将您的包安装到site-packages中。")]),_._v(" "),e("li",[_._v("通过简单直接的路径设置来解决导入的问题。")])]),_._v(" "),e("p",[_._v("我极力推荐后者。如果使用 "),e("code",[_._v("setup.py develop")]),_._v(" 来测试一个持续更新的代码库，需要为每一个版本的代码库设置一个独立的测试环境.太麻烦了。")]),_._v(" "),e("p",[_._v("可以先创建一个包含上下文环境的文件 "),e("code",[_._v("tests/context.py")]),_._v("。\nfile:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("import os\nimport sys\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\nimport sample\n")])])]),e("p",[_._v("然后，在每一个测试文件中，导入:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("from .context import sample\n")])])]),e("p",[_._v("这样就能够像期待的那样工作，而不用采用安装的方式。")]),_._v(" "),e("p",[_._v("一些人会说应该把您的测试例子放到您的模块里面 -- 我不同意。这样会增加您用户使用的复杂度；而且添加测试模块将导致需要额外的依赖和运行环境。")]),_._v(" "),e("p",[_._v("Makefile\n::::::::")]),_._v(" "),e("p",[_._v(".. csv-table::\n:widths: 20, 40")]),_._v(" "),e("p",[_._v('"布局", "'),e("code",[_._v("./Makefile")]),_._v('"\n"作用", "常规的管理任务"')]),_._v(" "),e("p",[_._v("如果您看看我的项目或者其他开源项目，您都会发现有一个Makefile。为什么？这些项目也不是用C写的啊。。。简而言之，make对于定义常规的管理任务是非常有用的工具。")]),_._v(" "),e("p",[_._v("** 样例 Makefile:**")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("init:\n    pip install -r requirements.txt\n\ntest:\n    py.test tests\n\nPHONY: init test\n")])])]),e("p",[_._v("一些其他的常规管理脚本（比如 "),e("code",[_._v("manage.py")]),_._v(" 或者 "),e("code",[_._v("fabfile.py")]),_._v("），也放在仓库的根目录下。")]),_._v(" "),e("p",[_._v("关于 Django Applications\n:::::::::::::::::::::::::::::")]),_._v(" "),e("p",[_._v("从Django 1.4开始，我发现有这样一个现象：很多开发者错误地使用Django自带的应用模板创建项目，导致他们的仓库结构非常糟糕。")]),_._v(" "),e("p",[_._v("这是怎么回事儿? 是的, 他们在进入一个新的仓库后，通常都这样操作：")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("$ django-admin.py startproject samplesite\n")])])]),e("p",[_._v("这样的操作生成的仓库结构是这样的:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("README.rst\nsamplesite/manage.py\nsamplesite/samplesite/settings.py\nsamplesite/samplesite/wsgi.py\nsamplesite/samplesite/sampleapp/models.py\n")])])]),e("p",[_._v("亲，不要这样做。")]),_._v(" "),e("p",[_._v("相对路径会让您的工具和您的开发者都很疑惑。没有必要的嵌套对任何人都没有好处（除非您怀念庞大的SVN仓库）。")]),_._v(" "),e("p",[_._v("让我们这样来做:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("$ django-admin.py startproject samplesite .\n")])])]),e("p",[_._v('注意末尾的 "'),e("code",[_._v(".")]),_._v('"。')]),_._v(" "),e("p",[_._v("生成的结构是这样的:")]),_._v(" "),e("p",[_._v("::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("README.rst\nmanage.py\nsamplesite/settings.py\nsamplesite/wsgi.py\nsamplesite/sampleapp/models.py\n")])])]),e("hr"),_._v(" "),e("p",[_._v("结构是一把钥匙")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("得益于Python提供的导入与管理模块的方式，结构化Python项目变得相对简单。\n这里说的简单，指的是结构化过程没有太多约束限制而且模块导入功能容易掌握。\n因而您只剩下架构性的工作，包括设计、实现项目各个模块，并整理清他们之间\n的交互关系。")]),_._v(" "),e("p",[_._v("容易结构化的项目同样意味着它的结构化容易做得糟糕。糟糕结构的特征包括：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("多重且混乱的循环依赖关系：假如在 :file:"),e("code",[_._v("furn.py")]),_._v(" 内的Table与Chair类需要\n导入 :file:"),e("code",[_._v("workers.py")]),_._v(" 中的Carpenter类以回答类似 "),e("code",[_._v("table.isdoneby()")]),_._v("\n的问题，并且Carpenter类需要引入Table和Chair类以回答 "),e("code",[_._v("carpenter.whatdo()")]),_._v("\n这类问题，这就是一种循环依赖的情况。在这种情况下,您得借助一些不怎么靠谱的\n小技巧，比如在方法或函数内部使用import语句。")])]),_._v(" "),e("li",[e("p",[_._v("隐含耦合：Table类实现代码中每一个改变都会打破20个不相关的测试用例，由于它\n影响了Carpenter类的代码，这要求谨慎地操作以适应改变。这样的情况意味着\nCarpenter类代码中包含了太多关于Table类的假设关联（或相反）。")])]),_._v(" "),e("li",[e("p",[_._v("大量使用全局变量或上下文：如果Table和Carpenter类使用不仅能被修改而且能被\n不同引用修改的全局变量，而不是明确地传递 "),e("code",[_._v("(height, width, type, wood)")]),_._v("\n变量。您就需要彻底检查全局变量的所有入口，来理解到为什么一个长方形桌子变\n成了正方形，最后发现远程的模板代码修改了这份上下文，弄错了桌子尺寸规格的\n定义。")])]),_._v(" "),e("li",[e("p",[_._v("面条式代码 (Spaghetti code) ：多页嵌套的if语句与for循环，包含大量复制-粘贴\n的过程代码，且没有合适的分割——这样的代码被称为面条式代码。Python中有意思\n的缩进排版(最具争议的特性之一)使面条式代码很难维持。所以好消息是您也许不\n会经常看到这种面条式代码。")])]),_._v(" "),e("li",[e("p",[_._v("Python中更可能出现混沌代码：这类代码包含上百段相似的逻辑碎片，通常是缺乏\n合适结构的类或对象，如果您始终弄不清手头上的任务应该使用FurnitureTable，\nAssetTable还是Table，甚至TableNew，也许您已经陷入了混沌代码中。")])])]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("模块")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Python模块是最主要的抽象层之一，并且很可能是最自然的一个。抽象层允许将代码分为\n不同部分，每个部分包含相关的数据与功能。")]),_._v(" "),e("p",[_._v("例如在项目中，一层控制用户操作相关接口，另一层处理底层数据操作。最自然分开这两\n层的方式是，在一份文件里重组所有功能接口，并将所有底层操作封装到另一个文件中。\n这种情况下，接口文件需要导入封装底层操作的文件，可通过 "),e("code",[_._v("import")]),_._v(" 和\n"),e("code",[_._v("from ... import")]),_._v(" 语句完成。一旦您使用 "),e("code",[_._v("import")]),_._v(" 语句，就可以使用这个模块。\n既可以是内置的模块包括 "),e("code",[_._v("os")]),_._v(" 和 "),e("code",[_._v("sys")]),_._v("，也可以是已经安装的第三方的模块，或者项目\n内部的模块。")]),_._v(" "),e("p",[_._v("为遵守风格指南中的规定，模块名称要短、使用小写，并避免使用特殊符号，比如点(.)\n和问号(?)。如 :file:"),e("code",[_._v("my.spam.py")]),_._v(" 这样的名字是必须不能用的！该方式命名将妨碍\nPython的模块查找功能。就 "),e("code",[_._v("my.spam.py")]),_._v(" 来说，Python 认为需要在 :file:"),e("code",[_._v("my")]),_._v(" 文件夹\n中找到 :file:"),e("code",[_._v("spam.py")]),_._v(" 文件，实际并不是这样。这个例子\n"),e("code",[_._v("example <http://docs.python.org/tutorial/modules.html#packages>")]),_._v("_ 展示了点表示\n法应该如何在Python文件中使用。如果愿意您可以将模块命名为 :file:"),e("code",[_._v("my_spam.py")]),_._v("，\n不过并不推荐在模块名中使用下划线。但是，在模块名称中使用其他字符（空格或连字号）\n将阻止导入（-是减法运算符），因此请尽量保持模块名称简单，以无需分开单词。\n最重要的是，不要使用下划线命名空间，而是使用子模块。")]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("h1",{attrs:{id:"ok"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ok"}},[_._v("#")]),_._v(" OK")]),_._v(" "),e("p",[_._v("import library.plugin.foo")]),_._v(" "),e("h1",{attrs:{id:"not-ok"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#not-ok"}},[_._v("#")]),_._v(" not OK")]),_._v(" "),e("p",[_._v("import library.foo_plugin")]),_._v(" "),e("p",[_._v("除了以上的命名限制外，Python文件成为模块没有其他特殊的要求，但为了合理地使用这\n个观念并避免问题，您需要理解import的原理机制。具体来说，"),e("code",[_._v("import modu")]),_._v(" 语句将\n寻找合适的文件，即调用目录下的 :file:"),e("code",[_._v("modu.py")]),_._v(' 文件（如果该文件存在）。如果没有\n找到这份文件，Python解释器递归地在 "PYTHONPATH" 环境变量中查找该文件，如果仍没\n有找到，将抛出ImportError异常。')]),_._v(" "),e("p",[_._v("一旦找到 :file:"),e("code",[_._v("modu.py")]),_._v("，Python解释器将在隔离的作用域内执行这个模块。所有顶层\n语句都会被执行，包括其他的引用。方法与类的定义将会存储到模块的字典中。然后，这个\n模块的变量、方法和类通过命名空间暴露给调用方，这是Python中特别有用和强大的核心概念。")]),_._v(" "),e("p",[_._v("在很多其他语言中，"),e("code",[_._v("include file")]),_._v(" 指令被预处理器用来获取文件里的所有代码并‘复制’\n到调用方的代码中。Python则不一样：include代码被独立放在模块命名空间里，这意味着您\n一般不需要担心include的代码可能造成不好的影响，例如重载同名方法。")]),_._v(" "),e("p",[_._v("也可以使用import语句的特殊形式 "),e("code",[_._v("from modu import *")]),_._v(" 模拟更标准的行为。但 "),e("code",[_._v("import *")]),_._v(" 通常\n被认为是不好的做法。"),e("strong",[_._v("使用")]),_._v(" "),e("code",[_._v("from modu import *")]),_._v(" "),e("strong",[_._v("的代码较难阅读而且依赖独立性不足")]),_._v("。\n使用 "),e("code",[_._v("from modu import func")]),_._v(" 能精确定位您想导入的方法并将其放到本地命名空间中。\n比 "),e("code",[_._v("from modu import *")]),_._v(" 要好些，因为它明确地指明往本地命名空间中导入了什么方法，它和\n"),e("code",[_._v("import modu")]),_._v(" 相比唯一的优点是之后使用方法时可以少打点儿字。")]),_._v(" "),e("p",[e("strong",[_._v("差")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("[...]\nfrom modu import *\n[...]\nx = sqrt(4)  # sqrt是模块modu的一部分么？或是内建函数么？上文定义了么？\n")])])]),e("p",[e("strong",[_._v("稍好")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("from modu import sqrt\n[...]\nx = sqrt(4)  # 如果在import语句与这条语句之间，sqrt没有被重复定义，它也许是模块modu的一部分。\n")])])]),e("p",[e("strong",[_._v("最好的做法")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("import modu\n[...]\nx = modu.sqrt(4)  # sqrt显然是属于模块modu的。\n")])])]),e("p",[_._v("在 :ref:"),e("code",[_._v("code_style")]),_._v(" 章节中提到，可读性是Python最主要的特性之一。可读性意味着避免\n无用且重复的文本和混乱的结构，因而需要花费一些努力以实现一定程度的简洁。但不能\n过份简洁而导致简短晦涩。除了简单的单文件项目外，其他项目需要能够明确指出类和方法\n的出处，例如使用 "),e("code",[_._v("modu.func")]),_._v(" 语句，这将显著提升代码的可读性和易理解性。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("包")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Python提供非常简单的包管理系统，即简单地将模块管理机制扩展到一个目录上(目录扩\n展为包)。")]),_._v(" "),e("p",[_._v("任意包含 :file:"),e("code",[_._v("__init__.py")]),_._v(" 文件的目录都被认为是一个Python包。导入一个包里不同\n模块的方式和普通的导入模块方式相似，特别的地方是 :file:"),e("code",[_._v("__init__.py")]),_._v(" 文件将集合\n所有包范围内的定义。")]),_._v(" "),e("p",[_._v(":file:"),e("code",[_._v("pack/")]),_._v(" 目录下的 :file:"),e("code",[_._v("modu.py")]),_._v(" 文件通过 "),e("code",[_._v("import pack.modu")]),_._v(" 语句导入。\n该语句会在 :file:"),e("code",[_._v("pack")]),_._v(" 目录下寻找 :file:"),e("code",[_._v("__init__.py")]),_._v(" 文件，并执行其中所有顶层\n语句。以上操作之后，:file:"),e("code",[_._v("modu.py")]),_._v(" 内定义的所有变量、方法和类在pack.modu命名空\n间中均可看到。")]),_._v(" "),e("p",[_._v("一个常见的问题是往 :file:"),e("code",[_._v("__init__.py")]),_._v(" 中加了过多代码，随着项目的复杂度增长，\n目录结构越来越深，子包和更深嵌套的子包可能会出现。在这种情况下，导入多层嵌套\n的子包中的某个部件需要执行所有通过路径里碰到的 :file:"),e("code",[_._v("__init__.py")]),_._v(" 文件。如果\n包内的模块和子包没有代码共享的需求，使用空白的 :file:"),e("code",[_._v("__init__.py")]),_._v(" 文件是正常\n甚至好的做法。")]),_._v(" "),e("p",[_._v("最后，导入深层嵌套的包可用这个方便的语法："),e("code",[_._v("import very.deep.module as mod")]),_._v("。\n该语法允许使用 "),e("code",[_._v("mod")]),_._v(" 替代冗长的 "),e("code",[_._v("very.deep.module")]),_._v("。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("面向对象编程")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Python有时被描述为面向对象编程的语言，这多少是个需要澄清的误导。在Python中\n一切都是对象，并且能按对象的方式处理。这么说的意思是，例如函数是一等对象。\n函数、类、字符串乃至类型都是Python对象：与其他对象一样，他们有类型，能作为\n函数参数传递，并且还可能有自己的方法和属性。这样理解的话，Python是一种面向\n对象语言。")]),_._v(" "),e("p",[_._v("然而，与Java不同的是，Python并没有将面向对象编程作为最主要的编程范式。非面向\n对象的Python项目(比如，使用较少甚至不使用类定义，类继承，或其它面向对象编程的\n机制)也是完全可行的。")]),_._v(" "),e("p",[_._v("此外在 模块_ 章节里曾提到，Python管理模块与命名空间的方式提供给开发者一个自然\n的方式以实现抽象层的封装和分离，这是使用面向对象最常见的原因。因而，如果业务逻辑\n没有要求，Python开发者有更多自由去选择不使用面向对象。")]),_._v(" "),e("p",[_._v("在一些情况下，需要避免不必要的面向对象。当我们想要将状态与功能结合起来，使用\n标准类定义是有效的。但正如函数式编程所讨论的那个问题，函数式的“变量”状态与类的\n状态并不相同。")]),_._v(" "),e("p",[_._v("在某些架构中，典型代表是web应用，大量Python进程实例被产生以响应可能同时到达的\n外部请求。在这种情况下，在实例化对象内保持某些状态，即保持某些环境静态信息，\n容易出现并发问题或竞态条件。有时候在对象状态的初始化(通常通过 "),e("code",[_._v("__init__()")]),_._v("\n方法实现)和在其方法中使用该状态之间，环境发生了变化，保留的状态可能已经过时。\n举个例子，某个请求将对象加载到内存中并标记它为已读。如果同时另一个请求要删除\n这个对象，删除操作可能刚好发生在第一个请求加载完该对象之后，结果就是第一个请\n求标记了一个已经被删除的对象为已读。")]),_._v(" "),e("p",[_._v("这些问题使我们产生一个想法：使用无状态的函数是一种更好的编程范式。另一种建议\n是尽量使用隐式上下文和副作用较小的函数与程序。函数的隐式上下文由函数内部访问\n到的所有全局变量与持久层对象组成。副作用即函数可能使其隐式上下文发生改变。如\n果函数保存或删除全局变量或持久层中数据，这种行为称为副作用。")]),_._v(" "),e("p",[_._v("把有隐式上下文和副作用的函数与仅包含逻辑的函数(纯函数)谨慎地区分开来，会带来\n以下好处：")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("纯函数的结果是确定的：给定一个输入，输出总是固定相同。")])]),_._v(" "),e("li",[e("p",[_._v("当需要重构或优化时，纯函数更易于更改或替换。")])]),_._v(" "),e("li",[e("p",[_._v("纯函数更容易做单元测试：很少需要复杂的上下文配置和之后的数据清除工作。")])]),_._v(" "),e("li",[e("p",[_._v("纯函数更容易操作、修饰和分发。")])])]),_._v(" "),e("p",[_._v("总之，对于某些架构而言，纯函数比类和对象在构建模块时更有效率，因为他们没有任何\n上下文和副作用。但显然在很多情况下，面向对象编程是有用甚至必要的。例如图形桌面\n应用或游戏的开发过程中，操作的元素(窗口、按钮、角色、车辆)在计算机内存里拥有相\n对较长的生命周期。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("装饰器")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Python语言提供一个简单而强大的语法: '装饰器'。装饰器是一个函数或类，它可以\n包装(或装饰)一个函数或方法。被 '装饰' 的函数或方法会替换原来的函数或方法。\n由于在Python中函数是一等对象，它也可以被 '手动操作'，但是使用@decorators\n语法更清晰，因此首选这种方式。")]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("def foo():\n    # 实现语句\n\ndef decorator(func):\n    # 操作func语句\n    return func\n\nfoo = decorator(foo)  # 手动装饰\n\n@decorator\ndef bar():\n    # 实现语句\n# bar()被装饰了\n")])])]),e("p",[_._v("这个机制对于分离概念和避免外部不相关逻辑“污染”主要逻辑很有用处。\n"),e("code",[_._v("记忆化 <https://en.wikipedia.org/wiki/Memoization#Overview>")]),_._v(" 或缓存就是一个很\n好的使用装饰器的例子：您需要在table中储存一个耗时函数的结果，并且下次能直接\n使用该结果，而不是再计算一次。这显然不属于函数的逻辑部分。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("上下文管理器")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("上下文管理器是一个Python对象，为操作提供了额外的上下文信息。 这种额外的信息，\n在使用 "),e("code",[_._v("with")]),_._v(" 语句初始化上下文，以及完成 "),e("code",[_._v("with")]),_._v(" 块中的所有代码时，采用可调用的形式。\n这里展示了使用上下文管理器的为人熟知的示例，打开文件：")]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("with open('file.txt') as f:\n    contents = f.read()\n")])])]),e("p",[_._v("任何熟悉这种模式的人都知道以这种形式调用 "),e("code",[_._v("open")]),_._v(" 能确保 "),e("code",[_._v("f` 的")]),_._v("close`` 方法会在某个时候被调用。\n这样可以减少开发人员的认知负担，并使代码更容易阅读。")]),_._v(" "),e("p",[_._v("实现这个功能有两种简单的方法：使用类或使用生成器。 让我们自己实现上面的功能，以使用类方式开始：")]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("class CustomOpen(object):\n    def __init__(self, filename):\n        self.file = open(filename)\n\n    def __enter__(self):\n        return self.file\n\n    def __exit__(self, ctx_type, ctx_value, ctx_traceback):\n        self.file.close()\n\nwith CustomOpen('file') as f:\n    contents = f.read()\n")])])]),e("p",[_._v("这只是一个常规的Python对象，它有两个由 "),e("code",[_._v("with")]),_._v(" 语句使用的额外方法。\nCustomOpen 首先被实例化，然后调用它的"),e("code",[_._v("__enter__``方法，而且 ``__enter__`` 的返回值在 ``as f`` 语句中被赋给 ``f`` 。 当 ``with`` 块中的内容执行完后，会调用")]),e("strong",[_._v("exit")]),_._v("`` 方法。")]),_._v(" "),e("p",[_._v("而生成器方式使用了Python自带的\n"),e("code",[_._v("contextlib <https://docs.python.org/3/library/contextlib.html>")]),_._v("_:")]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("from contextlib import contextmanager\n\n@contextmanager\ndef custom_open(filename):\n    f = open(filename)\n    try:\n        yield f\n    finally:\n        f.close()\n\nwith custom_open('file') as f:\n    contents = f.read()\n")])])]),e("p",[_._v("这与上面的类示例道理相通，尽管它更简洁。"),e("code",[_._v("custom_open")]),_._v(" 函数一直运行到 "),e("code",[_._v("yield")]),_._v(" 语句。\n然后它将控制权返回给 "),e("code",[_._v("with")]),_._v(" 语句，然后在 "),e("code",[_._v("as f")]),_._v(" 部分将yield的 "),e("code",[_._v("f")]),_._v(" 赋值给f。\n"),e("code",[_._v("finally")]),_._v(" 确保不论 "),e("code",[_._v("with")]),_._v(" 中是否发生异常， "),e("code",[_._v("close()")]),_._v(" 都会被调用。")]),_._v(" "),e("p",[_._v("由于这两种方法都是一样的，所以我们应该遵循Python之禅来决定何时使用哪种。\n如果封装的逻辑量很大，则类的方法可能会更好。 而对于处理简单操作的情况，函数方法可能会更好。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("动态类型")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Python是动态类型语言，这意味着变量并没有固定的类型。实际上，Python 中的变量和其他\n语言有很大的不同，特别是静态类型语言。变量并不是计算机内存中被写入的某个值，它们\n只是指向内存的 ‘标签’ 或 ‘名称’ 。因此可能存在这样的情况，变量 'a' 先代表值1，然后变成\n字符串 'a string' , 然后又变为指向一个函数。")]),_._v(" "),e("p",[_._v("Python 的动态类型常被认为是它的缺点，的确这个特性会导致复杂度提升和难以调试的代码。\n命名为 'a' 的变量可能是各种类型，开发人员或维护人员需要在代码中追踪命名，以保证它\n没有被设置到毫不相关的对象上。")]),_._v(" "),e("p",[_._v("这里有些避免发生类似问题的参考方法：")]),_._v(" "),e("ul",[e("li",[_._v("避免对不同类型的对象使用同一个变量名")])]),_._v(" "),e("p",[e("strong",[_._v("差")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("a = 1\na = 'a string'\ndef a():\n    pass  # 实现代码\n")])])]),e("p",[e("strong",[_._v("好")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("count = 1\nmsg = 'a string'\ndef func():\n    pass  # 实现代码\n")])])]),e("p",[_._v("使用简短的函数或方法能降低对不相关对象使用同一个名称的风险。即使是相关的不同\n类型的对象，也更建议使用不同命名：")]),_._v(" "),e("p",[e("strong",[_._v("差")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("items = 'a b c d'  # 首先指向字符串...\nitems = items.split(' ')  # ...变为列表\nitems = set(items)  # ...再变为集合\n")])])]),e("p",[_._v("重复使用命名对效率并没有提升：赋值时无论如何都要创建新的对象。然而随着复杂度的\n提升，赋值语句被其他代码包括 'if' 分支和循环分开，使得更难查明指定变量的类型。\n在某些代码的做法中，例如函数编程，推荐的是从不重复对同一个变量命名赋值。Java\n内的实现方式是使用 'final' 关键字。Python并没有 'final' 关键字而且这与它的哲学\n相悖。尽管如此，避免给同一个变量命名重复赋值仍是是个好的做法，并且有助于掌握\n可变与不可变类型的概念。")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("可变和不可变类型")]),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Python提供两种内置或用户定义的类型。可变类型允许内容的内部修改。典型的动态类型\n包括列表与字典：列表都有可变方法，如 :py:meth:"),e("code",[_._v("list.append")]),_._v(" 和 :py:meth:"),e("code",[_._v("list.pop")]),_._v('，\n并且能就地修改。字典也是一样。不可变类型没有修改自身内容的方法。比如，赋值为整数\n6的变量 x 并没有 "自增" 方法，如果需要计算 x + 1，必须创建另一个整数变量并给其命名。')]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("my_list = [1, 2, 3]\nmy_list[0] = 4\nprint my_list  # [4, 2, 3] <- 原列表改变了\n\nx = 6\nx = x + 1  # x 变量是一个新的变量\n")])])]),e("p",[_._v("这种差异导致的一个后果就是，可变类型是不 '稳定 '的，因而不能作为字典的键使用。合理地\n使用可变类型与不可变类型有助于阐明代码的意图。例如与列表相似的不可变类型是元组，\n创建方式为 "),e("code",[_._v("(1, 2)")]),_._v("。元组本身是不可修改的，若里面所有元素都是不可变类型，则能作为字典的键使用。")]),_._v(" "),e("p",[_._v("Python 中一个可能会让初学者惊讶的特性是：字符串是不可变类型。这意味着,\n在从字符串的各个部分构造字符串时, 将每个部分追加到字符串上是效率低下的,\n因为在每次追加时都会复制字符串的全部内容。\n反之，将每一部分放到一个可变列表里，需要使用字符串时再粘合 ("),e("code",[_._v("join")]),_._v(") 起来的做法更高效。\n列表推导通常是最快且最地道的方式来完成此目的。")]),_._v(" "),e("p",[e("strong",[_._v("差")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v('# 创建将0到19连接起来的字符串 (例 "012..1819")\nnums = ""\nfor n in range(20):\n    nums += str(n)   # 慢且低效\nprint nums\n')])])]),e("p",[e("strong",[_._v("更好")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v('# 创建将0到19连接起来的字符串 (例 "012..1819")\nnums = []\nfor n in range(20):\n    nums.append(str(n))\nprint "".join(nums)  # 更高效\n')])])]),e("p",[e("strong",[_._v("最好")])]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v('# 创建将0到19连接起来的字符串 (例 "012..1819")\nnums = [str(n) for n in range(20)]\nprint "".join(nums)\n')])])]),e("p",[_._v("最后关于字符串的说明的一点是，使用 "),e("code",[_._v("join()")]),_._v(" 并不总是最好的选择。比如当用预先\n确定数量的字符串创建一个新的字符串时，使用加法操作符确实更快，但在上文提到的情况\n下或添加到已存在字符串的情况下，使用 "),e("code",[_._v("join()")]),_._v(" 是更好的选择。")]),_._v(" "),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("foo = 'foo'\nbar = 'bar'\n\nfoobar = foo + bar  # 好的做法\nfoo += 'ooo'  # 不好的做法, 应该这么做:\nfoo = ''.join([foo, 'ooo'])\n")])])]),e("p",[_._v(".. note::")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("除了 :py:meth:`str.join` 和 ``+``，您也可以使用 :ref:`% <python:string-formatting>` \n格式运算符来连接确定数量的字符串，但 :pep:`3101` 建议使用 :py:meth:`str.format`\n替代 ``%`` 操作符。\n")])])]),e("p",[_._v(".. code-block:: python")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[_._v("foo = 'foo'\nbar = 'bar'\n\nfoobar = '%s%s' % (foo, bar) # 可行\nfoobar = '{0}{1}'.format(foo, bar) # 更好\nfoobar = '{foo}{bar}'.format(foo=foo, bar=bar) # 最好\n")])])]),e("hr"),_._v(" "),e("p",[_._v("提供依赖关系")]),_._v(" "),e("hr"),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("Runners")]),_._v(" "),e("hr"),_._v(" "),e("hr"),_._v(" "),e("p",[_._v("更多阅读")]),_._v(" "),e("hr"),_._v(" "),e("ul",[e("li",[_._v("http://docs.python.org/3/library/")]),_._v(" "),e("li",[_._v("https://diveintopython3.net/")])])])}),[],!1,null,null,null);v.default=t.exports}}]);