(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{492:function(s,t,e){s.exports=e.p+"assets/img/ClusterIP.772541e5.png"},493:function(s,t,e){s.exports=e.p+"assets/img/NodePort.73932a09.png"},494:function(s,t,e){s.exports=e.p+"assets/img/LoadBalancer.ba6167c4.png"},495:function(s,t,e){s.exports=e.p+"assets/img/IPVS1.5d5cda0d.png"},496:function(s,t,e){s.exports=e.p+"assets/img/IPVS2.5af1b8b8.png"},497:function(s,t,e){s.exports=e.p+"assets/img/IPVS3.53424cf4.png"},758:function(s,t,e){"use strict";e.r(t);var a=e(4),n=Object(a.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("blockquote",[a("p",[s._v("Kubernetes Pod 是有生命周期的。 它们可以被创建，而且销毁之后不会再启动。 如果您使用 Deployment 来运行您的应用程序，则它可以动态创建和销毁 Pod。")]),s._v(" "),a("p",[s._v("每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。")]),s._v(" "),a("p",[s._v("这导致了一个问题： 如果一组 Pod（称为“后端”）为群集内的其他 Pod（称为“前端”）提供功能， 那么前端如何找出并跟踪要连接的 IP 地址，以便前端可以使用工作量的后端部分？")])]),s._v(" "),a("p",[s._v("Pod的生命是有限的，如果Pod重启，IP很有可能会发生变化。如果我们的服务都是将Pod的IP地址写死，Pod的IP变化时，后端其他服务也将会不可用。当然我们可以通过手动修改如nginx的反向代理配置来适应后端的服务IP改变，但K8S中的Service对象可以帮助我们自动完成这一功能。")]),s._v(" "),a("blockquote",[a("p",[s._v("在讨论 Kubernetes 网络连接的方式之前，非常值得与 Docker 中 “正常” 方式的网络进行对比。")]),s._v(" "),a("p",[s._v("默认情况下，Docker 使用私有主机网络连接，只能与同在一台机器上的容器进行通信。 为了实现容器的跨节点通信，必须在机器自己的 IP 上为这些容器分配端口，"),a("strong",[s._v("为容器进行端口转发或者代理")]),s._v("。")]),s._v(" "),a("p",[s._v("多个开发人员之间协调端口的使用很难做到规模化，那些难以控制的集群级别的问题，都会交由用户自己去处理。 "),a("strong",[s._v("Kubernetes 假设 Pod 可与其它 Pod 通信，不管它们在哪个主机上")]),s._v("。 我们"),a("strong",[s._v("给 Pod 分配属于自己的集群私有 IP 地址")]),s._v("，所以没必要在 Pod 或映射到的容器的端口和主机端口之间显式地创建连接。 这表明了在 Pod 内的容器都能够连接到本地的每个端口，集群中的所有 Pod 不需要通过 NAT 转换就能够互相看到。")])]),s._v(" "),a("h2",{attrs:{id:"定义service"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义service"}},[s._v("#")]),s._v(" 定义Service")]),s._v(" "),a("p",[s._v("如果现在有一个暴露了8080端口的Pod，它被打上了"),a("code",[s._v("app=the-nginx")]),s._v("的标签，有两个副本：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" apps/v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Deployment\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" just"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("nginx\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("replicas")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("template")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("labels")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("app")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("nginx\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("containers")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("nginx\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("image")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" nginx\n        "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("containerPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("p",[s._v("那么这Pod的两个副本会拥有两个不同的IP地址，在集群中的任何一个容器内都可以通过IP地址访问到这两个副本，但其本身并没有占用其所部署节点的端口，因此无法从外部访问到。")]),s._v(" "),a("p",[s._v("如果我们想从其他Pod（在集群内）通过80端口访问它，那就要创建一个"),a("code",[s._v("Service")]),s._v("将外部端口80映射到有标签"),a("code",[s._v("app=the-nginx")]),s._v("的Pod的8080端口：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("selector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("app")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("nginx\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("protocol")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" TCP\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("80")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("targetPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("上述配置创建一个名称为"),a("code",[s._v("the-service")]),s._v("的 "),a("code",[s._v("Service")]),s._v(" 对象，它会将请求代理到使用 TCP 端口 8080，并且具有标签"),a("code",[s._v("app=the-nginx")]),s._v('的 Pod 上。Kubernetes为该服务分配一个IP地址（有时称为 "集群IP"），该IP地址由服务代理使用。服务选择算符的控制器不断扫描与其选择器匹配的Pod，然后将所有更新发布到也称为'),a("code",[s._v("the-service")]),s._v("的 "),a("code",[s._v("Endpoint")]),s._v(" 对象。")]),s._v(" "),a("h2",{attrs:{id:"查看service"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看service"}},[s._v("#")]),s._v(" 查看Service")]),s._v(" "),a("p",[s._v("查看当前Namespace中的Service")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("$ kubectl  get svc\nNAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("S"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("          AGE\nhttpd-svc          NodePort    "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.108")]),s._v(".195.47   "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v(":30088/TCP   16h\nkubernetes         ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.96")]),s._v(".0.1       "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("443")]),s._v("/TCP          115d\nmysql-production   ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.102")]),s._v(".208.69   "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3306")]),s._v("/TCP         14d\norder              NodePort    "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.99")]),s._v(".99.88     "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v(":30080/TCP   17d\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br")])]),a("p",[s._v("查看所有Namespace中的Service")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("$ kubectl  get svc --all-namespaces\nNAMESPACE     NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("S"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("                          AGE\nblog          mysql                  ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.101")]),s._v(".134.172   "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3306")]),s._v("/TCP                         30d\nblog          wordpress              NodePort    "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.107")]),s._v(".173.113   "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("80")]),s._v(":32255/TCP                     30d\ndefault       httpd-svc              ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.108")]),s._v(".195.47    "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v("/TCP                         3m\ndefault       kubernetes             ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.96")]),s._v(".0.1        "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("443")]),s._v("/TCP                          114d\ndefault       mysql-production       ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.102")]),s._v(".208.69    "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3306")]),s._v("/TCP                         13d\ndefault       order                  NodePort    "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.99")]),s._v(".99.88      "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v(":30080/TCP                   16d\nkube-ops      jenkins2               NodePort    "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.111")]),s._v(".112.3     "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v(":30005/TCP,50000:30340/TCP   17d\nkube-system   kube-dns               ClusterIP   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.96")]),s._v(".0.10       "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("53")]),s._v("/UDP,53/TCP                    114d\nkube-system   kubernetes-dashboard   NodePort    "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10.108")]),s._v(".149.176   "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("none"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("443")]),s._v(":30002/TCP                    111d\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("h2",{attrs:{id:"service分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service分类"}},[s._v("#")]),s._v(" Service分类")]),s._v(" "),a("blockquote",[a("p",[s._v("对一些应用（如前端）的某些部分，可能希望通过外部 Kubernetes 集群外部 IP 地址暴露 Service。")])]),s._v(" "),a("blockquote",[a("p",[s._v("Kubernetes ServiceTypes 允许指定一个需要的类型的 Service，默认是 "),a("code",[s._v("ClusterIP")]),s._v(" 类型。")])]),s._v(" "),a("h3",{attrs:{id:"clusterip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#clusterip"}},[s._v("#")]),s._v(" ClusterIP")]),s._v(" "),a("blockquote",[a("p",[a("strong",[s._v("通过集群的内部 IP 暴露服务")]),s._v("，选择该值，服务只能够在集群内部可以访问，这也是默认的ServiceType。")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(492),alt:"ClusterIP"}})]),s._v(" "),a("h3",{attrs:{id:"nodeport"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nodeport"}},[s._v("#")]),s._v(" NodePort")]),s._v(" "),a("blockquote",[a("p",[a("strong",[s._v("通过每个 Node 节点上的 IP 和静态端口（NodePort）暴露服务")]),s._v("。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求，可以从集群的外部访问一个 NodePort 服务。")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(493),alt:"NodePort"}})]),s._v(" "),a("p",[s._v("例如，若要从集群外访问上面那个Pod，可以使用：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("selector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("app")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("nginx\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("type")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" NodePort\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("protocol")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" TCP\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("80")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("targetPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("nodePort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("80")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br")])]),a("blockquote",[a("p",[s._v("如果将 type 字段设置为 NodePort，则 Kubernetes 控制平面将在 --service-node-port-range 标志指定的范围内分配端口（默认值：30000-32767）。 每个节点将那个端口（每个节点上的相同端口号）代理到您的服务中。 您的服务在其 .spec.ports[*].nodePort 字段中要求分配的端口。")])]),s._v(" "),a("blockquote",[a("p",[s._v("如果您想指定特定的 IP 代理端口，则可以将 kube-proxy 中的 --nodeport-addresses 标志设置为特定的 IP 块。从 Kubernetes v1.10 开始支持此功能。")]),s._v(" "),a("p",[s._v("该标志采用逗号分隔的 IP 块列表（例如，10.0.0.0/8、192.0.2.0/25）来指定 kube-proxy 应该认为是此节点本地的 IP 地址范围。")])]),s._v(" "),a("h3",{attrs:{id:"将服务暴露给指定的外部ip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#将服务暴露给指定的外部ip"}},[s._v("#")]),s._v(" 将服务暴露给指定的外部IP")]),s._v(" "),a("p",[s._v("比如，我想让上面的Pod只能从指定外部IP访问：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("selector")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("app")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("nginx\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("type")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" NodePort\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("protocol")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" TCP\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("80")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("targetPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8080")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("externalIPs")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" 80.11.12.10 "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#只能从这个外部IP访问")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br")])]),a("h3",{attrs:{id:"loadbalancer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loadbalancer"}},[s._v("#")]),s._v(" LoadBalancer")]),s._v(" "),a("p",[s._v("早在K8S项目成熟之前，各大云计算厂商都依托大规模集群实现了自己成熟的负载均衡方案，有极强的负载均衡能力，K8S显然也不能浪费这种能力。")]),s._v(" "),a("blockquote",[a("p",[a("strong",[s._v("使用云提供商的负载局衡器")]),s._v("，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务，这个需要结合具体的云厂商进行操作。")])]),s._v(" "),a("p",[a("img",{attrs:{src:e(494),alt:"LoadBalancer"}})]),s._v(" "),a("p",[s._v("云厂商的LoadBalancer插件主流的实现方式：")]),s._v(" "),a("ol",[a("li",[s._v("让Service以NodePort形式启动")]),s._v(" "),a("li",[s._v("向云厂商的负载均衡配置接口报告Pod所在Node的IP和NodePort端口")]),s._v(" "),a("li",[s._v("云厂商的负载均衡器按照上报的IP和NodePort自动将流量导到Node上，进而导到Pod中")])]),s._v(" "),a("p",[s._v("除了这种方式外，云厂商自然也还可以通过控制集群网络中的网络策略（路由器路由表等）实现负载均衡转发。")]),s._v(" "),a("h3",{attrs:{id:"externalname"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#externalname"}},[s._v("#")]),s._v(" ExternalName")]),s._v(" "),a("blockquote",[a("p",[a("strong",[s._v("通过返回 CNAME 和它的值")]),s._v("，可以将服务映射到 externalName 字段的内容（例如， foo.bar.example.com）。没有任何类型代理被创建，这只有 Kubernetes 1.7 或更高版本的 kube-dns 才支持。")])]),s._v(" "),a("blockquote",[a("p",[s._v("大多数 Kubernetes 用户都有可能用到集群外部的服务。例如，您可能使用 Twillio API 发送短信，或使用 Google Cloud Vision API 进行图像分析。")]),s._v(" "),a("p",[s._v("如果位于不同环境中的应用连接相同的外部端点，并且您不打算将外部服务引入 Kubernetes 集群，那么在代码中直接使用外部服务端点是完全可以的。然而，很多时候情况并非如此。")])]),s._v(" "),a("p",[s._v("一个典型的情况是，我的集群中需要使用一个托管在外部网络中的数据库，而我想在集群中通过一个固定的域名访问它，比如这个数据库是一个MySQL数据库"),a("code",[s._v("mysql://my.sql.database.example.com")]),s._v("，那么我们就可以在集群中定义一个"),a("code",[s._v("ExternalName")]),s._v("类型的Service：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" the"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v("mysql\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("type")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" ExternalName\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("externalName")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" my.sql.database.example.com\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("然后我就可以在集群中通过"),a("code",[s._v("mysql://the-mysql")]),s._v("访问它了。")]),s._v(" "),a("p",[s._v("注：因为是基于DNS的，所以"),a("code",[s._v("ExternalName")]),s._v("没有和端口有关的功能。")]),s._v(" "),a("h3",{attrs:{id:"使用ip访问外部服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用ip访问外部服务"}},[s._v("#")]),s._v(" 使用IP访问外部服务")]),s._v(" "),a("p",[s._v("除了上面的"),a("code",[s._v("ExternalName")]),s._v("外，还不得不提使用外部IP访问外部服务的情况。当我有多个外部数据库且部署在同一个位置的不同端口的时候，使用ExternalName就有点麻烦了。这个时候就可以使用一个Headless Services加一个"),a("code",[s._v("Endpoints")]),s._v("将外部IP绑定到集群内：")]),s._v(" "),a("div",{staticClass:"language-yml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Service\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" mongo\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("spec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("27017")]),s._v("\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("targetPort")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("49763")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("---")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("kind")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" Endpoints\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("apiVersion")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" v1\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("metadata")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("name")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" mongo\n"),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("subsets")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("addresses")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ip")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" 35.188.8.12\n      "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("ports")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("-")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token key atrule"}},[s._v("port")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("49763")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br")])]),a("h4",{attrs:{id:"附加知识：headless-services"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附加知识：headless-services"}},[s._v("#")]),s._v(" 附加知识：Headless Services")]),s._v(" "),a("blockquote",[a("p",[s._v('有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（spec.clusterIP）的值为 "None" 来创建 Headless Service。')]),s._v(" "),a("p",[s._v("您可以使用无头 Service 与其他服务发现机制进行接口，而不必与 Kubernetes 的实现捆绑在一起。")]),s._v(" "),a("p",[s._v("对这无头 Service 并不会分配 Cluster IP，kube-proxy 不会处理它们， 而且平台也不会为它们进行负载均衡和路由。 DNS 如何实现自动配置，依赖于 Service 是否定义了选择算符。")]),s._v(" "),a("h5",{attrs:{id:"带选择算符的服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#带选择算符的服务"}},[s._v("#")]),s._v(" 带选择算符的服务")]),s._v(" "),a("p",[s._v("对定义了选择算符的无头服务，Endpoint 控制器在 API 中创建了 Endpoints 记录， 并且修改 DNS 配置返回 A 记录（地址），通过这个地址直接到达 Service 的后端 Pod 上。")]),s._v(" "),a("h5",{attrs:{id:"无选择算符的服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无选择算符的服务"}},[s._v("#")]),s._v(" 无选择算符的服务")]),s._v(" "),a("p",[s._v("对没有定义选择算符的无头服务，Endpoint 控制器不会创建 Endpoints 记录。 然而 DNS 系统会查找和配置，无论是：")]),s._v(" "),a("ul",[a("li",[s._v("ExternalName 类型 Service 的 CNAME 记录")]),s._v(" "),a("li",[s._v("记录：与 Service 共享一个名称的任何 Endpoints，以及所有其它类型")])])]),s._v(" "),a("h2",{attrs:{id:"service-拓扑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-拓扑"}},[s._v("#")]),s._v(" Service 拓扑")]),s._v(" "),a("p",[s._v("默认情况下，发往 "),a("code",[s._v("ClusterIP")]),s._v(" 或者 "),a("code",[s._v("NodePort")]),s._v(" 服务的流量可能会被路由到任意一个服务后端的地址上，Service拓扑可以"),a("strong",[s._v("让一个服务基于集群的节点进行流量路由")]),s._v("，即"),a("strong",[s._v("把流量路由到指定节点的Pod上")]),s._v("。例如，一个服务可以指定流量是被优先路由到一个和客户端在同一个 "),a("code",[s._v("Node")]),s._v(" 或者在同一可用区域的端点，以获得低延迟。")]),s._v(" "),a("h3",{attrs:{id:"开启-service-拓扑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开启-service-拓扑"}},[s._v("#")]),s._v(" 开启 Service 拓扑")]),s._v(" "),a("p",[s._v("为了启用拓扑感知服务路由功能，必须要满足以下一些前提条件：")]),s._v(" "),a("ul",[a("li",[s._v("Kubernetes 的版本不低于 1.17")]),s._v(" "),a("li",[s._v("Kube-proxy 运行在 iptables 模式或者 IPVS 模式")]),s._v(" "),a("li",[s._v("启用 "),a("RouterLink",{attrs:{to:"/zh/docs/concepts/services-networking/endpoint-slices/"}},[s._v("端点切片")]),s._v("功能")],1)]),s._v(" "),a("p",[s._v("要启用 "),a("code",[s._v("Service")]),s._v(" 拓扑，就要给 kube-apiserver 和 kube-proxy 启用 "),a("code",[s._v("ServiceTopology")]),s._v(" 功能：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("--feature-gates"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"ServiceTopology=true"')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h3",{attrs:{id:"使用-service-拓扑"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-service-拓扑"}},[s._v("#")]),s._v(" 使用 Service 拓扑")]),s._v(" "),a("p",[s._v("如果集群启用了 "),a("code",[s._v("Service")]),s._v(" 拓扑功能后，就可以"),a("strong",[s._v("在 "),a("code",[s._v("Service")]),s._v(" 配置中指定 "),a("code",[s._v("topologyKeys")]),s._v(" 字段")]),s._v("，从而控制 "),a("code",[s._v("Service")]),s._v(" 的流量路由。此字段是 "),a("strong",[a("code",[s._v("Node")]),s._v(" 标签的优先顺序字段")]),s._v("，将用于在访问这个 "),a("code",[s._v("Service")]),s._v(" 时对端点进行排序：")]),s._v(" "),a("ul",[a("li",[s._v("流量会被定向到第一个标签值和源 "),a("code",[s._v("Node")]),s._v(" 标签值相匹配的 "),a("code",[s._v("Node")]),s._v("。")]),s._v(" "),a("li",[s._v("如果这个 "),a("code",[s._v("Service")]),s._v(" 没有匹配的后端 "),a("code",[s._v("Node")]),s._v("，那么第二个标签会被使用做匹配")]),s._v(" "),a("li",[s._v("以此类推，直到没有标签。")]),s._v(" "),a("li",[s._v("如果没有匹配到，流量会被拒绝，就如同这个 "),a("code",[s._v("Service")]),s._v(" 根本没有后端。")])]),s._v(" "),a("p",[s._v("这个字段配置为 "),a("code",[s._v('"*"')]),s._v(" 意味着任意拓扑。这个通配符值如果使用了，那么只有作为配置值列表中的最后一个才有用。")]),s._v(" "),a("h2",{attrs:{id:"原理简介-集群网络系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理简介-集群网络系统"}},[s._v("#")]),s._v(" 原理简介——集群网络系统")]),s._v(" "),a("blockquote",[a("p",[s._v("集群网络系统是 Kubernetes 的核心部分，但是想要准确了解它的工作原理可是个不小的挑战。下面列出的是网络系统的的四个主要问题：")]),s._v(" "),a("ol",[a("li",[s._v("高度耦合的容器间通信：这个已经在Pod的结构内部解决了。")]),s._v(" "),a("li",[s._v("Pod 间通信：这个是本文档的重点要讲述的。")]),s._v(" "),a("li",[s._v("Pod 和 Service 间通信：这个已经在上文里讲述过了。")]),s._v(" "),a("li",[s._v("外部和 Service 间通信：这个也已经在上文里讲述过了。")])]),s._v(" "),a("p",[s._v("Kubernetes 的"),a("strong",[s._v("宗旨就是在应用之间共享机器")]),s._v("。通常来说，共享机器需要两个应用之间不能使用相同的端口，但是在多个应用开发者之间去大规模地协调端口是件很困难的事情，尤其是还要让用户暴露在他们控制范围之外的集群级别的问题上。")]),s._v(" "),a("p",[s._v("动态分配端口也会给系统带来很多复杂度 - 每个应用都需要设置一个端口的参数，而 API 服务器还需要知道如何将动态端口数值插入到配置模块中，服务也需要知道如何找到对方等等。与其去解决这些问题，Kubernetes 选择了其他不同的方法。")]),s._v(" "),a("h3",{attrs:{id:"kubernetes-网络模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kubernetes-网络模型"}},[s._v("#")]),s._v(" Kubernetes 网络模型")]),s._v(" "),a("p",[a("strong",[s._v("每一个 "),a("code",[s._v("Pod")]),s._v(" 都有它自己的IP地址")]),s._v("，这就意味着你不需要显式地在每个 "),a("code",[s._v("Pod")]),s._v(" 之间创建链接，你几乎不需要处理容器端口到主机端口之间的映射。这将创建一个干净的、向后兼容的模型，在这个模型里，从端口分配、命名、服务发现、负载均衡、应用配置和迁移的角度来看，"),a("code",[s._v("Pod")]),s._v(" 可以被视作虚拟机或者物理主机。")]),s._v(" "),a("p",[s._v("Kubernetes 对所有网络设施的实施，都需要满足以下的基本要求（除非有设置一些特定的网络分段策略）：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("节点上的 pods 可以不通过 NAT 和其他任何节点上的 pods 通信")])]),s._v(" "),a("li",[a("strong",[s._v("节点上的代理（比如：系统守护进程、kubelet） 可以和节点上的所有pods通信")])])]),s._v(" "),a("p",[s._v("备注：仅针对那些支持 "),a("code",[s._v("Pods")]),s._v(" 在主机网络中运行的平台(比如：Linux) ：")]),s._v(" "),a("ul",[a("li",[s._v("那些运行在节点的主机网络里的 pods 可以不通过 NAT 和所有节点上的 pods 通信")])]),s._v(" "),a("p",[s._v("这个模型不仅不复杂，而且还和 Kubernetes 的实现廉价的从虚拟机向容器迁移的初衷相兼容，如果你的工作开始是在虚拟机中运行的，你的虚拟机有一个 IP ，这样就可以和其他的虚拟机进行通信，这是基本相同的模型。")]),s._v(" "),a("p",[s._v("Kubernetes 的 IP 地址存在于 "),a("code",[s._v("Pod")]),s._v(" 范围内 - 容器分享他们的网络命名空间 - 包括他们的 IP 地址。这就意味着 "),a("strong",[a("code",[s._v("Pod")]),s._v(" 内的容器都可以通过 "),a("code",[s._v("localhost")]),s._v(" 到达各个端口")]),s._v("。这也意味着 "),a("code",[s._v("Pod")]),s._v(" 内的容器都需要相互协调端口的使用，但是这和虚拟机中的进程似乎没有什么不同，这也被称为“一个 pod 一个 IP” 模型。")]),s._v(" "),a("p",[s._v("如何实现这一点是正在使用的容器运行时的特定信息。")]),s._v(" "),a("p",[s._v("也可以在 "),a("code",[s._v("node")]),s._v(" 本身通过端口去请求你的 "),a("code",[s._v("Pod")]),s._v(" （称之为主机端口），但这是一个很特殊的操作。转发方式如何实现也是容器运行时的细节。"),a("code",[s._v("Pod")]),s._v(" 自己并不知道这些主机端口是否存在。")])]),s._v(" "),a("h2",{attrs:{id:"原理简介-kube-proxy、vip-和-service-代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理简介-kube-proxy、vip-和-service-代理"}},[s._v("#")]),s._v(" 原理简介——"),a("code",[s._v("kube-proxy")]),s._v("、VIP 和 Service 代理")]),s._v(" "),a("blockquote",[a("p",[s._v("在 Kubernetes 集群中，每个 Node 运行一个 "),a("code",[s._v("kube-proxy")]),s._v(" 进程。\n"),a("code",[s._v("kube-proxy")]),s._v(" 负责为 Service 实现了一种 VIP（虚拟 IP）的形式，而不是\n"),a("code",[s._v("ExternalName")]),s._v(" 的形式。")])]),s._v(" "),a("h3",{attrs:{id:"kube-proxy的三种代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kube-proxy的三种代理模式"}},[s._v("#")]),s._v(" "),a("code",[s._v("kube-proxy")]),s._v("的三种代理模式")]),s._v(" "),a("h4",{attrs:{id:"userspace-代理模式-通过代理端口传数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#userspace-代理模式-通过代理端口传数据"}},[s._v("#")]),s._v(" userspace 代理模式 - 通过代理端口传数据")]),s._v(" "),a("blockquote",[a("p",[s._v("这种模式，kube-proxy 会监视 Kubernetes 主控节点对 Service 对象和 Endpoints 对象的添加和移除操作。"),a("strong",[s._v("对每个 Service，它会在本地 Node 上打开一个端口（随机选择）")]),s._v("。"),a("strong",[s._v("任何连接到“代理端口”的请求，都会被代理到 Service 的后端 "),a("code",[s._v("Pods")]),s._v(" 中的某个上面")]),s._v("（如 "),a("code",[s._v("Endpoints")]),s._v(" 所报告的一样）。\n使用哪个后端 Pod，是 kube-proxy 基于 "),a("code",[s._v("SessionAffinity")]),s._v(" 来确定的。")]),s._v(" "),a("p",[s._v("最后，它配置 iptables 规则，捕获到达该 Service 的 "),a("code",[s._v("clusterIP")]),s._v("（是虚拟 IP）和 "),a("code",[s._v("Port")]),s._v(" 的请求，并重定向到代理端口，代理端口再代理请求到后端Pod。")]),s._v(" "),a("p",[s._v("默认情况下，用户空间模式下的 kube-proxy "),a("strong",[s._v("通过轮转算法选择后端")]),s._v("。")]),s._v(" "),a("p",[a("img",{attrs:{src:"i/services-userspace-overview.svg",alt:"userspace代理模式下Service概览图"}})])]),s._v(" "),a("h4",{attrs:{id:"iptables-代理模式-直接通过iptables传数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iptables-代理模式-直接通过iptables传数据"}},[s._v("#")]),s._v(" iptables 代理模式 - 直接通过iptables传数据")]),s._v(" "),a("blockquote",[a("p",[s._v("这种模式，"),a("code",[s._v("kube-proxy")]),s._v(" 会监视 Kubernetes 控制节点对 Service 对象和 Endpoints 对象的添加和移除。"),a("strong",[s._v("对每个 Service，它会配置 iptables 规则，从而捕获到达该 Service 的 "),a("code",[s._v("clusterIP")]),s._v(" 和端口的请求，进而将请求重定向到 Service 的一组后端中的某个 Pod 上面")]),s._v("。对于每个 Endpoints 对象，它也会配置 iptables 规则，这个规则会选择一个后端组合。")]),s._v(" "),a("p",[s._v("默认的策略是，kube-proxy 在 iptables 模式下随机选择一个后端。")]),s._v(" "),a("p",[a("img",{attrs:{src:"i/services-iptables-overview.svg",alt:"iptables代理模式下Service概览图"}})])]),s._v(" "),a("h4",{attrs:{id:"ipvs-代理模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ipvs-代理模式"}},[s._v("#")]),s._v(" IPVS 代理模式")]),s._v(" "),a("blockquote",[a("p",[s._v("在 "),a("code",[s._v("ipvs")]),s._v(" 模式下，kube-proxy监视Kubernetes服务和端点，调用 "),a("code",[s._v("netlink")]),s._v(" 接口相应地创建 IPVS 规则，并定期将 IPVS 规则与 Kubernetes 服务和端点同步。 该控制循环可确保IPVS 状态与所需状态匹配。访问服务时，IPVS 将流量定向到后端Pod之一。")]),s._v(" "),a("p",[s._v("IPVS代理模式基于类似于 iptables 模式的 netfilter 挂钩函数，但是使用哈希表作为基础数据结构，并且在内核空间中工作。这意味着，与 iptables 模式下的 kube-proxy 相比，IPVS 模式下的 kube-proxy重定向通信的延迟要短，并且在同步代理规则时具有更好的性能。与其他代理模式相比，IPVS 模式还支持更高的网络流量吞吐量。")]),s._v(" "),a("p",[s._v("IPVS提供了更多选项来平衡后端Pod的流量。 这些是：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("rr")]),s._v(": round-robin 轮叫调度，按依次循环的方式将请求调度到不同的服务器上")]),s._v(" "),a("li",[a("code",[s._v("lc")]),s._v(": least connection 最少链接，发给当前连接数最少的后端")]),s._v(" "),a("li",[a("code",[s._v("dh")]),s._v(": destination hashing 目标地址散列调度算法，根据目标 IP 地址通过散列函数将目标 IP 与服务器建立映射关系")]),s._v(" "),a("li",[a("code",[s._v("sh")]),s._v(": source hashing 源地址散列调度算法，根据源 IP 地址通过散列函数将源 IP 与服务器建立映射关系")]),s._v(" "),a("li",[a("code",[s._v("sed")]),s._v(": shortest expected delay")]),s._v(" "),a("li",[a("code",[s._v("nq")]),s._v(": never queue")])]),s._v(" "),a("p",[a("img",{attrs:{src:"i/services-ipvs-overview.svg",alt:"IPVS代理的 Services 概述图"}})])]),s._v(" "),a("h4",{attrs:{id:"iptables-vs-ipvs：service性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iptables-vs-ipvs：service性能"}},[s._v("#")]),s._v(" Iptables vs. IPVS：Service性能")]),s._v(" "),a("p",[s._v("每个节点都知道系统中所有Service的情况，会不会有性能问题？")]),s._v(" "),a("p",[a("img",{attrs:{src:e(495),alt:"IPVS"}}),s._v(" "),a("img",{attrs:{src:e(496),alt:"IPVS"}}),s._v(" "),a("img",{attrs:{src:e(497),alt:"IPVS"}})])])}),[],!1,null,null,null);t.default=n.exports}}]);