(window.webpackJsonp=window.webpackJsonp||[]).push([[277],{953:function(t,e,a){"use strict";a.r(e);var s=a(4),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"生成器函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成器函数"}},[t._v("#")]),t._v(" 生成器函数")]),t._v(" "),a("p",[t._v("在 Python 中，使用了 "),a("code",[t._v("yield")]),t._v("关键字 的函数被称为生成器（generator）。")]),t._v(" "),a("p",[t._v("跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作。")]),t._v(" "),a("p",[t._v("迭代器是一个可以记住遍历的位置的对象。")]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("yield")]),t._v("表达式在定义生成器函数或是异步生成器函数的时候才会用到。因此只能在函数定义的内部使用yield表达式。 在一个函数体内使用 "),a("code",[t._v("yield")]),t._v(" 表达式会使这个函数变成一个生成器。")]),t._v(" "),a("div",{staticClass:"language-python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("gen")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# defines a generator function")]),t._v("\n   v "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   v "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abc'")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'xxx'")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("当一个生成器函数被调用的时候，它"),a("strong",[t._v("返回一个迭代器控制生成器函数的执行")]),t._v("。当迭代器的"),a("code",[t._v("__next__()")]),t._v("或"),a("code",[t._v("send()")]),t._v("方法第一次被调用的时候，生成器函数开始执行。"),a("strong",[t._v("当执行到"),a("code",[t._v("yield")]),t._v("表达式处，生成器函数将被挂起，给迭代器的调用者返回"),a("code",[t._v("yield")]),t._v("后的表达式的值")]),t._v("。挂起时，所有局部状态都被保留下来，包括生成器函数内部局部变量的当前绑定，指令指针，内部求值栈和任何异常处理的状态。通过调用迭代器的"),a("code",[t._v("__next__()")]),t._v("或"),a("code",[t._v("send()")]),t._v("方法，生成器函数继续执行。")]),t._v(" "),a("p",[t._v("恢复后"),a("code",[t._v("yield")]),t._v("表达式的值取决于调用的哪个方法来恢复执行。如果用的是"),a("code",[t._v("__next__()")]),t._v("(通常通过语言内置的"),a("code",[t._v("for")]),t._v("或是"),a("code",[t._v("next()")]),t._v("来调用) 那么结果就是"),a("code",[t._v("None")]),t._v(". 否则，如果用"),a("code",[t._v("send()")]),t._v(", 那么结果就是传递给send方法的值。")])]),t._v(" "),a("p",[t._v("例如，对于上面的例子，我们可以这样调用：")]),t._v(" "),a("div",{staticClass:"language-python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" it "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" gen"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__next__"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("send"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("456")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("456")]),t._v("\nabc\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("it"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__next__"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("None")]),t._v("\nTraceback "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("most recent call last"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n  File "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<stdin>"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" line "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("module"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nStopIteration"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" xxx\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br")])]),a("p",[t._v("可以看到：")]),t._v(" "),a("ul",[a("li",[t._v("直接调用生成器函数"),a("code",[t._v("gen()")]),t._v("并不会实际执行生成器函数内的代码，而是返回了一个迭代器；")]),t._v(" "),a("li",[t._v("第一次调用迭代器的"),a("code",[t._v("__next__()")]),t._v("，从第一个"),a("code",[t._v("yeild")]),t._v("处返回了"),a("code",[t._v("123")]),t._v("；")]),t._v(" "),a("li",[t._v("第二次调用迭代器的"),a("code",[t._v("send()")]),t._v("，生成器函数"),a("code",[t._v("gen")]),t._v("内首先从第一个"),a("code",[t._v("yeild")]),t._v("处获得并输出了"),a("code",[t._v("send")]),t._v("发送进去的值，然后运行到第二个"),a("code",[t._v("yeild")]),t._v("处返回了"),a("code",[t._v("abc")]),t._v("；")]),t._v(" "),a("li",[t._v("最后再调用迭代器的"),a("code",[t._v("__next__()")]),t._v("时，可以看到生成器函数"),a("code",[t._v("gen")]),t._v("内从第二个"),a("code",[t._v("yeild")]),t._v("处获得的值为"),a("code",[t._v("None")]),t._v("，然后运行到"),a("code",[t._v("return")]),t._v("处报"),a("code",[t._v("StopIteration")]),t._v("错，并且将返回值"),a("code",[t._v("xxx")]),t._v("放到了错误里。")])]),t._v(" "),a("p",[t._v("完整的迭代器方法列表：")]),t._v(" "),a("blockquote",[a("ul",[a("li",[a("code",[t._v("generator.__next__()")]),t._v("：开始一个生成器函数的执行或是从上次执行的"),a("code",[t._v("yield")]),t._v("表达式位置恢复执行；")]),t._v(" "),a("li",[a("code",[t._v("generator.send(value)")]),t._v("：恢复执行并向生成器函数“发送”一个值。 value 参数将成为当前"),a("code",[t._v("yield")]),t._v("表达式的结果。")]),t._v(" "),a("li",[a("code",[t._v("generator.throw(type[, value[, traceback]])")]),t._v("：在生成器暂停的位置引发 "),a("code",[t._v("type")]),t._v(" 类型的异常，并返回该生成器函数所产生的下一个值。 如果生成器没有产生下一个值就退出，则将引发 "),a("code",[t._v("StopIteration")]),t._v(" 异常。如果生成器函数没有捕获传入的异常，或引发了另一个异常，则该异常会被传播给调用者。")]),t._v(" "),a("li",[a("code",[t._v("generator.close()")]),t._v("：在生成器函数暂停的位置引发 "),a("code",[t._v("GeneratorExit")]),t._v("。 如果之后生成器函数正常退出、关闭或引发 "),a("code",[t._v("GeneratorExit")]),t._v(" (由于未捕获该异常) 则关闭并返回其调用者。 如果生成器产生了一个值，关闭会引发 "),a("code",[t._v("RuntimeError")]),t._v("。 如果生成器引发任何其他异常，它会被传播给调用者。 如果生成器已经由于异常或正常退出则 "),a("code",[t._v("close()")]),t._v(" 不会做任何事。")])])]),t._v(" "),a("h2",{attrs:{id:"从生成器到协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从生成器到协程"}},[t._v("#")]),t._v(" 从生成器到协程")]),t._v(" "),a("blockquote",[a("p",[t._v("迭代器与协程非常相似；它们"),a("code",[t._v("yield")]),t._v("多次，它们具有多个入口点，并且它们的执行可以被挂起。唯一的区别是迭代器不能控制在它在"),a("code",[t._v("yield")]),t._v("后交给哪里继续执行；控制权总是转移到迭代器的调用者。")])]),t._v(" "),a("h3",{attrs:{id:"可等待对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可等待对象"}},[t._v("#")]),t._v(" 可等待对象")]),t._v(" "),a("p",[a("code",[t._v("awaitable")]),t._v("对象主要实现了"),a("code",[t._v("__await__()")]),t._v("方法。"),a("strong",[t._v("该方法必须返回一个迭代器")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"协程对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程对象"}},[t._v("#")]),t._v(" 协程对象")]),t._v(" "),a("blockquote",[a("p",[t._v("协程对象继承自"),a("code",[t._v("awaitable")]),t._v("对象。 协程的执行可通过调用"),a("code",[t._v("__await__()")]),t._v("并迭代其结果来控制。 当协程结束执行并返回时，迭代器会引发"),a("code",[t._v("StopIteration")]),t._v("，该异常的"),a("code",[t._v("value")]),t._v("属性将成为协程的返回值。如果协程引发了异常，它会被迭代器所传播。协程不应直接引发未处理的"),a("code",[t._v("StopIteration")]),t._v("异常。")]),t._v(" "),a("p",[t._v("除了"),a("code",[t._v("__await__()")]),t._v("外，协程对象还具有下面列出的方法，它们类似于生成器的对应方法。 但是，与生成器不同，协程并不直接支持迭代。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("coroutine.send(value)")]),t._v("：开始或恢复协程的执行。 如果 "),a("code",[t._v("value")]),t._v(" 为 "),a("code",[t._v("None")]),t._v("，则这相当于前往 "),a("code",[t._v("__await__()")]),t._v(" 所返回迭代器的下一项。 如果 "),a("code",[t._v("value")]),t._v(" 不为 "),a("code",[t._v("None")]),t._v("，此方法将委托给导致协程挂起的迭代器的 "),a("code",[t._v("send()")]),t._v(" 方法。 其结果（返回值，"),a("code",[t._v("StopIteration")]),t._v(" 或是其他异常）将与上述对 "),a("code",[t._v("__await__()")]),t._v(" 返回值进行迭代的结果相同。")]),t._v(" "),a("li",[a("code",[t._v("coroutine.throw(type[, value[, traceback]])")]),t._v("：在协程内引发指定的异常。 此方法将委托给导致协程挂起的迭代器的 "),a("code",[t._v("throw()")]),t._v(" 方法，如果存在该方法。 否则的话，异常会在挂起点被引发。 其结果（返回值，"),a("code",[t._v("StopIteration")]),t._v(" 或是其他异常）将与上述对 "),a("code",[t._v("__await__()")]),t._v(" 返回值进行迭代的结果相同。 如果异常未在协程内被捕获，则将回传给调用者。")]),t._v(" "),a("li",[a("code",[t._v("coroutine.close()")]),t._v("：此方法会使得协程清理自身并退出。 如果协程被挂起，此方法会先委托给导致协程挂起的迭代器的 "),a("code",[t._v("close()")]),t._v(" 方法，如果存在该方法。 然后它会在挂起点引发 "),a("code",[t._v("GeneratorExit")]),t._v("，使得协程立即清理自身。 最后，协程会被标记为已结束执行，即使它根本未被启动。当协程对象将要被销毁时，会使用以上处理过程来自动关闭。")])])]),t._v(" "),a("p",[t._v("可以看到，协程与迭代器非常相似，都是一个可以挂起和继续的对象，协程的底层就是基于迭代器在控制挂起和继续的操作。这也是为什么Python协程的教程都要从生成器和迭代器开始讲起。")]),t._v(" "),a("h3",{attrs:{id:"基于生成器的协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于生成器的协程"}},[t._v("#")]),t._v(" 基于生成器的协程")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("注解")]),t._v("：对基于生成器的协程的支持 "),a("strong",[t._v("已弃用")]),t._v(" 并计划在 Python 3.10 中移除。")]),t._v(" "),a("p",[t._v("基于生成器的协程是 async/await 语法的前身。它们是使用 "),a("code",[t._v("yield from")]),t._v(" 语句创建的 Python 生成器，可以等待 Future 和其他协程。")]),t._v(" "),a("p",[t._v("基于生成器的协程应该使用 "),a("code",[t._v("@asyncio.coroutine")]),t._v(" 装饰，虽然这并非强制。此装饰器使得旧式的基于生成器的协程能与 async/await 代码相兼容:")]),t._v(" "),a("div",{staticClass:"language-python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token decorator annotation punctuation"}},[t._v("@asyncio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("coroutine")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("old_style_coroutine")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("yield")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" asyncio"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sleep"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n   "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" old_style_coroutine"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("Deprecated since version 3.8, will be removed in version 3.10: 请改用 "),a("code",[t._v("async def")]),t._v("。")])]),t._v(" "),a("h2",{attrs:{id:"异步生成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步生成器"}},[t._v("#")]),t._v(" 异步生成器")]),t._v(" "),a("p",[t._v("在一个 "),a("code",[t._v("async def")]),t._v(" 定义的函数体内使用 "),a("code",[t._v("yield")]),t._v(" 表达式会让协程函数变成异步的生成器。")]),t._v(" "),a("blockquote",[a("p",[t._v("在一个使用 "),a("code",[t._v("async def")]),t._v(" 定义的函数或方法中出现的 "),a("code",[t._v("yield")]),t._v(" 表达式会进一步将该函数定义为一个异步生成器函数。")])]),t._v(" "),a("p",[t._v("异步生成器和生成器的方法类似，最大的区别在于其所有的方法返回的都是"),a("code",[t._v("awaitable")]),t._v("对象，在调用时要用"),a("code",[t._v("async for")]),t._v("。")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("generator.__anext__()")]),t._v("：返回一个可等待对象，功能同"),a("code",[t._v("generator.__next__()")]),t._v("；此方法通常是通过 async for 循环隐式地调用；")]),t._v(" "),a("li",[a("code",[t._v("generator.asend(value)")]),t._v("：返回一个可等待对象，功能同"),a("code",[t._v("generator.send(value)")]),t._v("；")]),t._v(" "),a("li",[a("code",[t._v("generator.athrow(type[, value[, traceback]])")]),t._v("：返回一个可等待对象，功能同"),a("code",[t._v("generator.throw(type[, value[, traceback]])")]),t._v("；")]),t._v(" "),a("li",[a("code",[t._v("generator.aclose()")]),t._v("：返回一个可等待对象，功能同"),a("code",[t._v("generator.close()")]),t._v("。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);